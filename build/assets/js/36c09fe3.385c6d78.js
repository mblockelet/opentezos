"use strict";(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[1167],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return f}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),c=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=c(e.components);return r.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),m=c(n),f=o,d=m["".concat(p,".").concat(f)]||m[f]||u[f]||a;return n?r.createElement(d,i(i({ref:t},s),{},{components:n})):r.createElement(d,i({ref:t},s))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7131:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return p},metadata:function(){return c},toc:function(){return s},default:function(){return m}});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),i=["components"],l={id:"michocoq",title:"Mi-Cho-Coq",authors:"Frank Hillard"},p=void 0,c={unversionedId:"formal-verification/michocoq",id:"formal-verification/michocoq",title:"Mi-Cho-Coq",description:"Introduction",source:"@site/docs/formal-verification/michocoq.md",sourceDirName:"formal-verification",slug:"/formal-verification/michocoq",permalink:"/opentezos/formal-verification/michocoq",editUrl:"https://gitlab.com/tezos-paris-hub/opentezos/-/blob/main/docs/formal-verification/michocoq.md",tags:[],version:"current",lastUpdatedBy:"Aymeric",lastUpdatedAt:1628108608,formattedLastUpdatedAt:"8/4/2021",frontMatter:{id:"michocoq",title:"Mi-Cho-Coq",authors:"Frank Hillard"},sidebar:"docs",previous:{title:"Generalities",permalink:"/opentezos/formal-verification/general"},next:{title:"Formal verification on smart contracts",permalink:"/opentezos/formal-verification/modeling-theorem"}},s=[{value:"Introduction",id:"introduction",children:[],level:3},{value:"Content",id:"content",children:[{value:"Type system",id:"type-system",children:[],level:4},{value:"Syntax",id:"syntax",children:[],level:4},{value:"Semantics",id:"semantics",children:[],level:4}],level:3}],u={toc:s};function m(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h3",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"Mi-Cho-Coq")," library represents the bridge between Tezos smart contract and formal proof in Coq."),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"Mi-Cho-Coq")," library ","[2]"," is a formalization of the Michelson language ","[9]"," using the Coq interactive theorem prover ","[1]","."),(0,a.kt)("p",null,"In practice, the ",(0,a.kt)("em",{parentName:"p"},"Mi-Cho-Coq"),' library is used to produce a formal definition of a Michelson script (e.g. the "Modeling theorem" ',(0,a.kt)("a",{parentName:"p",href:"/formal-verification/modeling-theorem#Example_vote"},"section"),"). Each Michelson instruction has its equivalent in the ",(0,a.kt)("em",{parentName:"p"},"Mi-Cho-Coq")," library (e.g. see the syntax ",(0,a.kt)("a",{parentName:"p",href:"/formal-verification/michocoq#Syntax"},"subsection"),")."),(0,a.kt)("h3",{id:"content"},"Content"),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"Mi-Cho-Coq")," library provides a formal definition (in Gallina) of the ",(0,a.kt)("strong",{parentName:"p"},"type system")," (Michelson types), the ",(0,a.kt)("strong",{parentName:"p"},"syntax")," (instructions of the Michelson), the ",(0,a.kt)("strong",{parentName:"p"},"semantics")," (evaluator) and the lexing and parsing (for type-checking)."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"It is recommended to have notions of Language theory in order to understand the following Mi-Cho-Coq definition (grammar rules).")),(0,a.kt)("h4",{id:"type-system"},"Type system"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"type system")," consists in the definition of types (comparable types and non-comparable ones)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Inductive simple_comparable_type : Set :=\n| string\n| nat\n| int\n| bytes\n...\n\nInductive comparable_type : Set :=\n| Comparable_type_simple : simple_comparable_type -> comparable_type\n| Cpair : simple_comparable_type -> comparable_type -> comparable_type.\n\nInductive type : Set :=\n| Comparable_type (_ : simple_comparable_type)\n| key\n| unit\n| signature\n| option (a : type)\n| list (a : type)\n| set (a : comparable_type)\n| contract (a : type)\n| operation\n| pair (a : type) (b : type)\n| or (a : type) (_ : annot_o) (b : type) (_ : annot_o)\n| lambda (a b : type)\n| map (k : comparable_type) (v : type)\n| big_map (k : comparable_type) (v : type)\n| chain_id.\n")),(0,a.kt)("h4",{id:"syntax"},"Syntax"),(0,a.kt)("p",null,"The *",(0,a.kt)("strong",{parentName:"p"},"*syntax")," and typing of Michelson instructions are formalized as a dependent inductive type to rule out ill-typed instructions."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Inductive instruction :\n  forall (self_type : Datatypes.option type) (tail_fail_flag : Datatypes.bool) (A B : Datatypes.list type), Set :=\n| NOOP {A} : instruction A A\n| FAILWITH {A B a} : instruction (a ::: A) B\n| SEQ {A B C} : instruction A B -> instruction B C -> instruction A C\n| IF_ {A B} : instruction A B -> instruction A B -> instruction (bool ::: A) B\n| LOOP {A} : instruction A (bool ::: A) -> instruction (bool ::: A) A\n...\n")),(0,a.kt)("p",null,"Notice that the inductive type ",(0,a.kt)("inlineCode",{parentName:"p"},"instruction"),"  defines typing rules for each instruction (",(0,a.kt)("inlineCode",{parentName:"p"},"SEQ"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"IF"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"LOOP"),", ...)."),(0,a.kt)("h4",{id:"semantics"},"Semantics"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"semantics")," of types is defined by interpreting them with predefined ",(0,a.kt)("em",{parentName:"p"},"Coq")," types (e.g. int -> Z, nat -> N, mutez -> int63). The semantics of Michelson is defined by an evaluator ",(0,a.kt)("inlineCode",{parentName:"p"},"eval")," formalized as a ",(0,a.kt)("em",{parentName:"p"},"Fixpoint"),". "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Fixpoint eval {self_type} {tff} {env} {A : stack_type} {B : stack_type}\n         (i : instruction self_type tff A B) (fuel : Datatypes.nat) {struct fuel} :\n  stack A -> M (stack B) :=\n  match fuel with\n  | O => fun SA => Failed _ Out_of_fuel\n  | S n =>\n    match i, SA, env with\n    | FAILWITH, (x, _), _ => Failed _ (Assertion_Failure _ x)\n    | NOOP, SA, _ => Return SA\n    | DUP, (x, SA), _ => Return (x, (x, SA))\n    | SWAP, (x, (y, SA)), _ => Return (y, (x, SA))\n    | PUSH a x, SA, _ => Return (concrete_data_to_data _ x, SA)\n    | UNIT, SA, _ => Return (tt, SA)\n    | LAMBDA a b code, SA, _ => Return (existT _ _ code, SA)\n    | EQ, (x, SA), _ => Return ((x =? 0)%Z, SA)\n    | NEQ, (x, SA), _ => Return (negb (x =? 0)%Z, SA)\n    | LT, (x, SA), _ => Return ((x <? 0)%Z, SA)\n        | SEQ B C, SA, env => \n        let! r := eval env B n SA in\n        eval env C n r\n    | IF_ bt bf, (b, SA), env =>\n        if b then eval env bt n SA else eval env bf n SA\n    | LOOP body, (b, SA), env =>\n        if b then eval env (body;; (LOOP body)) n SA else Return SA\n...\n")),(0,a.kt)("p",null,"Notice that the evaluator defines actions that must be performed for each type of instruction."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Since evaluating a Michelson instruction might fail (whereas ",(0,a.kt)("em",{parentName:"p"},"Coq")," functions cannot), the return type of this evaluator is wrapped in an exception monad (handling errors such as overflow, lexing, parsing, fuel).")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Coq forbids non-terminating functions, so we use a common ",(0,a.kt)("em",{parentName:"p"},"Coq")," trick to define the evaluator on diverging instructions such as ",(0,a.kt)("em",{parentName:"p"},"LOOP"),": we make the evaluator structurally recursive on an extra argument of type Datatypes.nat called the ",(0,a.kt)("strong",{parentName:"p"},"fuel")," of the evaluator.")))}m.isMDXComponent=!0}}]);