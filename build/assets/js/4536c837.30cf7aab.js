"use strict";(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[7042],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return m}});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),p=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=p(e.components);return i.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=p(t),m=a,h=u["".concat(s,".").concat(m)]||u[m]||d[m]||o;return t?i.createElement(h,l(l({ref:n},c),{},{components:t})):i.createElement(h,l({ref:n},c))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,l=new Array(o);l[0]=u;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r.mdxType="string"==typeof e?e:a,l[1]=r;for(var p=2;p<o;p++)l[p]=t[p];return i.createElement.apply(null,l)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},5905:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return r},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return u}});var i=t(7462),a=t(3366),o=(t(7294),t(3905)),l=["components"],r={id:"examples",title:"More examples",authors:"Maxime Sallerin, Benjamin Pilia and Frank Hillard"},s=void 0,p={unversionedId:"ligo/examples",id:"ligo/examples",title:"More examples",description:"Function",source:"@site/docs/ligo/examples.md",sourceDirName:"ligo",slug:"/ligo/examples",permalink:"/ligo/examples",editUrl:"https://gitlab.com/tezos-paris-hub/opentezos/-/blob/main/docs/ligo/examples.md",tags:[],version:"current",lastUpdatedBy:"Aymeric",lastUpdatedAt:1628108608,formattedLastUpdatedAt:"8/4/2021",frontMatter:{id:"examples",title:"More examples",authors:"Maxime Sallerin, Benjamin Pilia and Frank Hillard"},sidebar:"docs",previous:{title:"Unit Testing with PyTezos",permalink:"/ligo/unit-testing"},next:{title:"Exam",permalink:"/ligo/exam"}},c=[{value:"Function",id:"function",children:[],level:2},{value:"Record",id:"record",children:[],level:2},{value:"Main function",id:"main-function",children:[],level:2},{value:"Option",id:"option",children:[],level:2},{value:"The Fund and its advisor",id:"the-fund-and-its-advisor",children:[{value:"Transaction workflow",id:"transaction-workflow",children:[],level:3},{value:"Lambda pattern",id:"lambda-pattern",children:[],level:3}],level:2},{value:"Requirement",id:"requirement",children:[],level:2},{value:"Sandboxed mode",id:"sandboxed-mode",children:[{value:"Run a sandboxed node",id:"run-a-sandboxed-node",children:[],level:3},{value:"Use the sandboxed client",id:"use-the-sandboxed-client",children:[],level:3},{value:"Activate a protocol",id:"activate-a-protocol",children:[],level:3}],level:2},{value:"First contract - Indice",id:"first-contract---indice",children:[{value:"Defining storage and entrypoints",id:"defining-storage-and-entrypoints",children:[],level:3},{value:"Defining the main function",id:"defining-the-main-function",children:[],level:3},{value:"Defining the entrypoints",id:"defining-the-entrypoints",children:[{value:"Increment",id:"increment",children:[],level:4},{value:"Decrement",id:"decrement",children:[],level:4},{value:"SendValue",id:"sendvalue",children:[],level:4}],level:3}],level:2},{value:"Second contract - Advisor",id:"second-contract---advisor",children:[{value:"Defining storage and entrypoints",id:"defining-storage-and-entrypoints-1",children:[],level:3},{value:"Defining the main function",id:"defining-the-main-function-1",children:[],level:3},{value:"Defining the entrypoints",id:"defining-the-entrypoints-1",children:[{value:"ReceiveValue",id:"receivevalue",children:[],level:4},{value:"RequestValue",id:"requestvalue",children:[],level:4},{value:"ChangeAlgorithm",id:"changealgorithm",children:[],level:4}],level:3}],level:2},{value:"Dry-run, compilation and deployment",id:"dry-run-compilation-and-deployment",children:[{value:"Indice contract",id:"indice-contract",children:[{value:"Simulation",id:"simulation",children:[],level:4},{value:"Compilation",id:"compilation",children:[],level:4},{value:"Deployment",id:"deployment",children:[],level:4}],level:3},{value:"Advisor contract",id:"advisor-contract",children:[{value:"Simulation",id:"simulation-1",children:[],level:4},{value:"Compilation",id:"compilation-1",children:[],level:4},{value:"Deployment",id:"deployment-1",children:[],level:4}],level:3},{value:"Use",id:"use",children:[],level:3}],level:2}],d={toc:c};function u(e){var n=e.components,r=(0,a.Z)(e,l);return(0,o.kt)("wrapper",(0,i.Z)({},d,r,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"function"},"Function"),(0,o.kt)("p",null,"The example below comes from ",(0,o.kt)("a",{parentName:"p",href:"https://tezosacademy.io/pascal/chapter-functions"},"Tezos Academy")," and represents a modification of the id of a ",(0,o.kt)("inlineCode",{parentName:"p"},"spaceship"),"."),(0,o.kt)("p",null,"So the following function takes a string ",(0,o.kt)("inlineCode",{parentName:"p"},"my_ship")," as input, modifies the third character to 1 and assigns the result to a constant ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_ship"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'type ship_code is string\nvar my_ship : ship_code := "020433"\nfunction modify_ship_code (const my_ship : ship_code) : ship_code is\n  block {\n    const modified_ship = String.sub(0n, 2n, my_ship) ^ "1" ^ String.sub(3n, 3n, my_ship)\n  } with modified_ship\n')),(0,o.kt)("p",null,"You can call the function ",(0,o.kt)("inlineCode",{parentName:"p"},"modify_ship_code")," defined above by using the LIGO dev tools:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run-function function_example.ligo modify_ship_code '020433'\n# Outputs: '021433'\n")),(0,o.kt)("h2",{id:"record"},"Record"),(0,o.kt)("p",null,"The structured type ",(0,o.kt)("inlineCode",{parentName:"p"},"record")," is here, used to define the coordinates of a planet in the solar system."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type coordinates is\n    record [\n        x : int;\n        y : int;\n        z : int\n    ]\n\nvar earth_coordinates : coordinates :=\n    record [\n        x = 2;\n        y = 7;\n        z = 1\n    ]\n\npatch earth_coordinates with record [z = 5]\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"A ",(0,o.kt)("inlineCode",{parentName:"p"},"patch with")," instruction takes a ",(0,o.kt)("inlineCode",{parentName:"p"},"record")," data structure to be updated and a subset of the fields to update, then modifies the recorded data structure in accordance to the new specified subset of fields.")),(0,o.kt)("h2",{id:"main-function"},"Main function"),(0,o.kt)("p",null,"In LIGO, the design aims to have one main function called ",(0,o.kt)("inlineCode",{parentName:"p"},"main"),", which dispatches the control flow according to its parameter. The functions used for those actions are called entrypoints."),(0,o.kt)("p",null,"In the example below:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The functions ",(0,o.kt)("inlineCode",{parentName:"li"},"set_ship_code")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"go_to")," are the entrypoints."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Set_ship_code")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"Go_to")," are the associated actions.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type parameter is\n  Set_ship_code of string\n| Go_to of string\n\ntype storage is record [\n  ship_code : string;\n  destination : string\n]\n\ntype return is list (operation) * storage\n\nfunction set_ship_code (const input_string : string; const store : storage) : return is\n  ((nil : list (operation)), store with record [ship_code = input_string])\n\nfunction go_to (const input_string : string; const store : storage) : return is\n  ((nil : list (operation)), store with record [destination = input_string])\n\nfunction main (const action : parameter; const store : storage): return is\n  case action of\n    Set_ship_code (input_string) -> set_ship_code (input_string, store)\n  | Go_to (input_string) -> go_to (input_string, store)\n  end\n")),(0,o.kt)("h2",{id:"option"},"Option"),(0,o.kt)("p",null,"The example below comes from ",(0,o.kt)("a",{parentName:"p",href:"https://tezosacademy.io/pascal/chapter-option"},"Tezos Academy")," and deals with the modification of the weapon power of a spaceship to illustrate the use of option types."),(0,o.kt)("p",null,"In the code below, we can see that the ",(0,o.kt)("em",{parentName:"p"},"weapons")," variable are defined as a mapping between the name of each weapon and its corresponding input of power. Here, we want to increase the power of the ",(0,o.kt)("em",{parentName:"p"},"Main Laser")," but the mapping returns an ",(0,o.kt)("em",{parentName:"p"},"optional")," result as it might not be found in the mapping. We define the constant ",(0,o.kt)("inlineCode",{parentName:"p"},"main_laser_power")," as an optional ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," by selecting ",(0,o.kt)("em",{parentName:"p"},"Main Laser")," from the weapons mapping."),(0,o.kt)("p",null,"We write a pattern matching the ",(0,o.kt)("inlineCode",{parentName:"p"},"main_laser_power"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If it exists, it increases the power of the ",(0,o.kt)("em",{parentName:"li"},"Main Laser")," by 1 (use ",(0,o.kt)("inlineCode",{parentName:"li"},"i")," as a temporary matching variable).  "),(0,o.kt)("li",{parentName:"ul"},"If it does not exist in the mapping, it will fail with ",(0,o.kt)("inlineCode",{parentName:"li"},"Weapon not found"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'type weapon_power is map (string, int)\n\nfunction main (const p : unit; const store : unit) : (list(operation) * unit) is\n  block {\n    const weapons : weapon_power =\n        map [\n            "Main Laser" -> 5;\n            "Right Laser" -> 2;\n            "Left Laser" -> 3;\n        ];\n\n    const main_laser_power : option(int) = weapons["Main Laser"];\n    case main_laser_power of\n      Some(i) -> weapons["Main Laser"] := i + 1\n    | None -> failwith("Weapon not found")\n    end\n\n  } with ((nil: list(operation)), unit)\n')),(0,o.kt)("h1",{id:"full-example---fundadvisor"},"Full example - FundAdvisor"),(0,o.kt)("p",null,"This example illustrates the communication between contracts (with get_entrypoint_opt LIGO function) and lambda patterns allowing you to modify a contract that is already deployed. The example showd implementing, deploying and interacting with Tezos smart contracts."),(0,o.kt)("h2",{id:"the-fund-and-its-advisor"},"The Fund and its advisor"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"indice")," contract represents a ",(0,o.kt)("em",{parentName:"p"},"fund")," value, and the ",(0,o.kt)("inlineCode",{parentName:"p"},"advisor")," contract gives an advice on investing in this fund."),(0,o.kt)("h3",{id:"transaction-workflow"},"Transaction workflow"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"advisor")," contract can be invoked to request the fund value to the ",(0,o.kt)("inlineCode",{parentName:"p"},"indice")," contract (via a transaction). The ",(0,o.kt)("inlineCode",{parentName:"p"},"indice")," contract receives the request (transaction)cand will send back the requested value. When the ",(0,o.kt)("inlineCode",{parentName:"p"},"advisor")," contract receives the fund value, it can apply the ",(0,o.kt)("em",{parentName:"p"},"algorithm")," to check if it is worth investing!"),(0,o.kt)("br",null),(0,o.kt)("p",null,(0,o.kt)("img",{src:t(4469).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 1: FundAdvisor"),(0,o.kt)("p",null,"The resulting advice is stored in the storage (in the result field)."),(0,o.kt)("h3",{id:"lambda-pattern"},"Lambda pattern"),(0,o.kt)("p",null,"The real business logic of the ",(0,o.kt)("inlineCode",{parentName:"p"},"advisor")," smart contract lies in the lambda function, which is defined in the storage.\nThe storage can be modified so does the business logic (lambda)."),(0,o.kt)("p",null,"Therefore an entrypoint with ",(0,o.kt)("inlineCode",{parentName:"p"},"ChangeAlgorithm")," is provided to modify the algorithm that computes the worth of the investment."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Lambda pattern"),(0,o.kt)("br",{parentName:"p"}),"\n","Changing the behaviour of a smart contract can be done by customizing its implementation through the lambda functions. The idea is to implement the smart contract logic in a lambda function that can be modified after the contract is deployed. Find out more about lambda ",(0,o.kt)("a",{parentName:"p",href:"https://tezosacademy.io/pascal/chapter-lambda"},"here"),".")),(0,o.kt)("h2",{id:"requirement"},"Requirement"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"A LIGO compiler, and a code editor installed. If not, go ",(0,o.kt)("a",{parentName:"li",href:"https://opentezos.com/ligo/installation"},"there"),"."),(0,o.kt)("li",{parentName:"ol"},"A sandboxed mode ready.")),(0,o.kt)("h2",{id:"sandboxed-mode"},"Sandboxed mode"),(0,o.kt)("p",null,"This part will explain to you how to run a 'localhost-only' instance of a Tezos network."),(0,o.kt)("h3",{id:"run-a-sandboxed-node"},"Run a sandboxed node"),(0,o.kt)("p",null,"For instance, if you want to run a local network with two nodes, in the first terminal, the following command will initialize a node listening for peers on port 19731 and listening for RPC on port 18731."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"./src/bin_node/tezos-sandboxed-node.sh 1 --connections 1\n")),(0,o.kt)("p",null,"To launch the second node, run the following command in another terminal, and it will listen to port 19739 and 18739:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"./src/bin_node/tezos-sandboxed-node.sh 9 --connections 1\n")),(0,o.kt)("h3",{id:"use-the-sandboxed-client"},"Use the sandboxed client"),(0,o.kt)("p",null,"Once your node is running, open a new terminal and initialize the ",(0,o.kt)("inlineCode",{parentName:"p"},"sandboxed")," client data in a temporary directory:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"eval `./src/bin_client/tezos-init-sandboxed-client.sh 1`\n")),(0,o.kt)("h3",{id:"activate-a-protocol"},"Activate a protocol"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-activate-alpha\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Find out more about sandboxed mode ",(0,o.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/user/sandbox.html"},"here"))),(0,o.kt)("h2",{id:"first-contract---indice"},"First contract - Indice"),(0,o.kt)("p",null,"The indice contract represents a fund value."),(0,o.kt)("h3",{id:"defining-storage-and-entrypoints"},"Defining storage and entrypoints"),(0,o.kt)("p",null,"Let's create a file ",(0,o.kt)("inlineCode",{parentName:"p"},"indice_types.ligo")," to put all the needed type definitions."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"indiceStorage")," is an integer type that can have the value of an equity."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"indiceEntrypoints")," determines how the contract will be invoked:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"By increasing the value of the contract storage by using ",(0,o.kt)("inlineCode",{parentName:"li"},"Increment of int"),"."),(0,o.kt)("li",{parentName:"ul"},"By decreasing it with ",(0,o.kt)("inlineCode",{parentName:"li"},"Decrement of int"),"."),(0,o.kt)("li",{parentName:"ul"},"By sending its value to another contract that has called it, using ",(0,o.kt)("inlineCode",{parentName:"li"},"SendValue of unit"),"."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"indiceFullReturn")," determines the return type of the main function.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// indice_types.ligo\n\ntype indiceStorage is int\n\ntype indiceEntrypoints is Increment of int | Decrement of int | SendValue of unit\n\ntype indiceFullReturn is list(operation) * indiceStorage\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note that the ",(0,o.kt)("inlineCode",{parentName:"p"},"sendValue")," entrypoint does not take any parameter.")),(0,o.kt)("h3",{id:"defining-the-main-function"},"Defining the main function"),(0,o.kt)("p",null,"Now let's move to the file ",(0,o.kt)("inlineCode",{parentName:"p"},"indice.ligo")," that includes the previous file ",(0,o.kt)("inlineCode",{parentName:"p"},"indice_types.ligo")," and create the main function ",(0,o.kt)("inlineCode",{parentName:"p"},"indiceMain")," with writing ",(0,o.kt)("inlineCode",{parentName:"p"},'#include "indice_types.ligo"')," at the beginning of the script."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'// indice.ligo\n`#include "indice_types.ligo"`\n\nfunction indiceMain(const ep : indiceEntrypoints; const store : indiceStorage) : indiceFullReturn is\nblock { skip } with ((nil: list(operation)), store )\n')),(0,o.kt)("p",null,"Let's keep the block empty for now and see if it compiles correctly."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile-contract indice.ligo indiceMain\n")),(0,o.kt)("p",null,"This should return:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"{ parameter or (or (int %decrement) (int %increment) (unit %sendValue)) ;\n  storage int ;\n  code { CDR ; NIL operation ; PAIR } }\n")),(0,o.kt)("p",null,"Now let's implement the three entrypoints:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'// indice.ligo\n`#include "indice_types.ligo"`\n\nfunction indiceMain(const ep : indiceEntrypoints; const store : indiceStorage) : indiceFullReturn is\nblock { \n    const ret : indiceFullReturn = case ep of \n    | Increment(p) -> increment(p, store)\n    | Decrement(p) -> decrement(p, store)\n    | SendValue(p) -> sendValue(p, store)\n    end;\n    \n } with ret\n')),(0,o.kt)("h3",{id:"defining-the-entrypoints"},"Defining the entrypoints"),(0,o.kt)("h4",{id:"increment"},"Increment"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"increment")," function takes two parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"param")," of type ",(0,o.kt)("inlineCode",{parentName:"li"},"int"),", which is the value that will be added to the storage,"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"s")," the initial value of the storage.")),(0,o.kt)("p",null,"This function's return type is ",(0,o.kt)("inlineCode",{parentName:"p"},"indiceFullReturn")," and returns:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"an empty list of operations,"),(0,o.kt)("li",{parentName:"ul"},"a modified storage with a new value of ",(0,o.kt)("inlineCode",{parentName:"li"},"s + param"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"//indice.ligo\n\nfunction increment(const param : int; const s : indiceStorage) : indiceFullReturn is \nblock { skip } with ((nil: list(operation)), s + param)\n")),(0,o.kt)("h4",{id:"decrement"},"Decrement"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"decrement")," function takes two parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"param")," of type ",(0,o.kt)("inlineCode",{parentName:"li"},"int"),", which is the value that will be removed from the storage,"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"s")," the initial value of the storage.")),(0,o.kt)("p",null,"This function's return type is ",(0,o.kt)("inlineCode",{parentName:"p"},"indiceFullReturn")," and returns:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"an empty list of operations,"),(0,o.kt)("li",{parentName:"ul"},"a modified storage with a new value of ",(0,o.kt)("inlineCode",{parentName:"li"},"s - param"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"//indice.ligo\n\nfunction decrement(const param : int; const s : indiceStorage) : indiceFullReturn is \nblock { skip } with ((nil: list(operation)), s - param)\n")),(0,o.kt)("h4",{id:"sendvalue"},"SendValue"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"sendValue")," function takes two parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"param")," of type ",(0,o.kt)("inlineCode",{parentName:"li"},"unit"),", which means it takes no parameter,"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"s")," the initial value of the storage.")),(0,o.kt)("p",null,"This function's return type is ",(0,o.kt)("inlineCode",{parentName:"p"},"indiceFullReturn")," and it returns:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"a list of operations containing a transaction,"),(0,o.kt)("li",{parentName:"ul"},"the initial storage that is not modified.")),(0,o.kt)("p",null,"The predefined function ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_entrypoint_opt")," can be used to retrieve the definition of a single entry point.  ",(0,o.kt)("inlineCode",{parentName:"p"},"%receiveValue")," is the label of the entrypoint that will be defined in the advisor contract."),(0,o.kt)("p",null,"When the function ",(0,o.kt)("inlineCode",{parentName:"p"},"get_entrypoint_opt")," does not find any contract at a given ",(0,o.kt)("inlineCode",{parentName:"p"},"address"),", or if the contract doesn't match the type, then ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," is returned."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note that the ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_entrypoint_opt")," function is a two-way communication solution between contract that are already deployed.\nFind out more on ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_entrypoint_opt")," ",(0,o.kt)("a",{parentName:"p",href:"https://tezosacademy.io/pascal/chapter-polymorphism"},"here"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'//indice.ligo\n\nfunction sendValue(const param : unit; const s : indiceStorage) : indiceFullReturn is \nblock { \n    const c_opt : option(contract(int)) = Tezos.get_entrypoint_opt("%receiveValue", Tezos.sender);\n    const receiver : contract(int) = case c_opt of\n    | Some(c) -> c\n    | None -> (failwith("sender cannot receive indice value") : contract(int))\n    end;\n    const op : operation = Tezos.transaction(s, 0mutez, receiver);\n    const txs : list(operation) = list [ op; ];\n } with (txs, s)\n')),(0,o.kt)("p",null,"Let's compile again the main function to be sure we made no mistakes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile-contract indice.ligo indiceMain\n")),(0,o.kt)("h2",{id:"second-contract---advisor"},"Second contract - Advisor"),(0,o.kt)("p",null,"Remember that the ",(0,o.kt)("inlineCode",{parentName:"p"},"advisor")," contract can be invoked to request the value of the fund from the ",(0,o.kt)("inlineCode",{parentName:"p"},"indice")," contract (via a transaction). The ",(0,o.kt)("inlineCode",{parentName:"p"},"indice")," contract receives the request transaction and will send back the requested value. When the ",(0,o.kt)("inlineCode",{parentName:"p"},"advisor")," contract receives the fund value, it can apply the ",(0,o.kt)("em",{parentName:"p"},"algorithm")," to check that it is worth investing."),(0,o.kt)("h3",{id:"defining-storage-and-entrypoints-1"},"Defining storage and entrypoints"),(0,o.kt)("p",null,"In a new file called ",(0,o.kt)("inlineCode",{parentName:"p"},"advisor_types.ligo")," we define:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"advisorStorage")," which is a record type containing three fields:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"indiceAddress")," of type ",(0,o.kt)("inlineCode",{parentName:"li"},"address")," to communicate with the ",(0,o.kt)("inlineCode",{parentName:"li"},"indice")," contract."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"algorithm")," that takes an ",(0,o.kt)("inlineCode",{parentName:"li"},"int")," as a parameter and returns a ",(0,o.kt)("inlineCode",{parentName:"li"},"bool"),", depending on the business logic."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"result")," that is ",(0,o.kt)("inlineCode",{parentName:"li"},"True")," if the investor should invest and ",(0,o.kt)("inlineCode",{parentName:"li"},"False")," otherwise."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"advisorEntrypoints")," that determines how the contract will be invoked:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"By receiving an integer value from another contract's storage with ",(0,o.kt)("inlineCode",{parentName:"li"},"ReceiveValue of int"),"."),(0,o.kt)("li",{parentName:"ul"},"By requesting this value with ",(0,o.kt)("inlineCode",{parentName:"li"},"sendValue of unit"),". "),(0,o.kt)("li",{parentName:"ul"},"By modifying the algorithm that computes the worth of the investment with ",(0,o.kt)("inlineCode",{parentName:"li"},"ChangeAlgorithm of advisorAlgo"),"."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"advisorFullReturn")," that determines the return type of the main function.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"//advisor_types.ligo\ntype advisorAlgo is int -> bool\n\ntype advisorStorage is record [\n    indiceAddress : address;\n    algorithm : advisorAlgo;\n    result : bool;\n]\n\ntype advisorEntrypoints is ReceiveValue of int | RequestValue of unit | ChangeAlgorithm of advisorAlgo\n\ntype advisorFullReturn is list(operation) * advisorStorage\n")),(0,o.kt)("h3",{id:"defining-the-main-function-1"},"Defining the main function"),(0,o.kt)("p",null,"Let's create another file ",(0,o.kt)("inlineCode",{parentName:"p"},"advisor.ligo")," that will include the previous file ",(0,o.kt)("inlineCode",{parentName:"p"},"advisor_types.ligo")," and create the main function ",(0,o.kt)("inlineCode",{parentName:"p"},"advisorMain"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'//advisor.ligo\n#include "advisor_types.ligo"\n\nfunction advisorMain(const ep : advisorEntrypoints; const store : advisorStorage) : advisorFullReturn is\nblock { \n    const ret : advisorFullReturn = case ep of \n    | ReceiveValue(p) -> execute(p, store)\n    | RequestValue(p) -> request(p, store)\n    | ChangeAlgorithm(p) -> change(p, store)\n    end;\n } with ret\n')),(0,o.kt)("h3",{id:"defining-the-entrypoints-1"},"Defining the entrypoints"),(0,o.kt)("h4",{id:"receivevalue"},"ReceiveValue"),(0,o.kt)("p",null,"Symmetrically to the ",(0,o.kt)("inlineCode",{parentName:"p"},"SendValue")," function defined for the indice contract, we define the ",(0,o.kt)("inlineCode",{parentName:"p"},"RequestValue")," function, so that the two-way communication can be complete."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"request")," function takes two parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"param")," of type ",(0,o.kt)("inlineCode",{parentName:"li"},"unit"),", which means it takes no parameter."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"s")," the initial value of the storage.")),(0,o.kt)("p",null,"This function's return type is ",(0,o.kt)("inlineCode",{parentName:"p"},"advisorFullReturn")," and returns:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"a list of operations containing a transaction,"),(0,o.kt)("li",{parentName:"ul"},"the initial storage that is not modified.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'//advisor.ligo\n\nfunction request(const p : unit; const s : advisorStorage) : advisorFullReturn is\nblock { \n    const c_opt : option(contract(unit)) = Tezos.get_entrypoint_opt("%sendValue", s.indiceAddress);\n    const receiver : contract(unit) = case c_opt of\n    | Some(c) -> c\n    | None -> (failwith("indice cannot send its value") : contract(unit))\n    end;\n    const op : operation = Tezos.transaction(unit, 0mutez, receiver);\n    const txs : list(operation) = list [ op; ];\n } with (txs, s)\n')),(0,o.kt)("h4",{id:"requestvalue"},"RequestValue"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"execute")," function takes two parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"indiceVal")," of type ",(0,o.kt)("inlineCode",{parentName:"li"},"int"),", which is the value that will be passed in the algorithm,"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"s")," the initial value of the storage.")),(0,o.kt)("p",null,"This function's return type is ",(0,o.kt)("inlineCode",{parentName:"p"},"advisorFullReturn")," and returns:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"an empty list of operations,"),(0,o.kt)("li",{parentName:"ul"},"a modified storage with a new value for ",(0,o.kt)("inlineCode",{parentName:"li"},"s.result")," that will be the boolean return of the algorithm.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"//advisor.ligo\n\nfunction execute(const indiceVal : int; const s : advisorStorage) : advisorFullReturn is\nblock { \n    s.result := s.algorithm(indiceVal)\n } with ((nil : list(operation)), s)\n")),(0,o.kt)("h4",{id:"changealgorithm"},"ChangeAlgorithm"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"change")," function takes two parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"p")," of type ",(0,o.kt)("inlineCode",{parentName:"li"},"advisorAlgo")," which is the algorithm function corresponding to the wanted business logic."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"s")," the initial value of the storage.")),(0,o.kt)("p",null,"This function's return type is ",(0,o.kt)("inlineCode",{parentName:"p"},"advisorFullReturn")," and returns:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"an empty list of operations"),(0,o.kt)("li",{parentName:"ul"},"a modified storage with a new value for ",(0,o.kt)("inlineCode",{parentName:"li"},"s.algorithm"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"//advisor.ligo\n\nfunction change(const p : advisorAlgo; const s : advisorStorage) : advisorFullReturn is\nblock { \n    s.algorithm := p;\n } with ((nil : list(operation)), s)\n")),(0,o.kt)("p",null,"Let's compile the main function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile-contract advisor.ligo advisorMain\n")),(0,o.kt)("h2",{id:"dry-run-compilation-and-deployment"},"Dry-run, compilation and deployment"),(0,o.kt)("h3",{id:"indice-contract"},"Indice contract"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'//indice.ligo\n#include "indice_types.ligo"\n\nfunction increment(const param : int; const s : indiceStorage) : indiceFullReturn is \nblock { skip } with ((nil: list(operation)), s + param)\n\nfunction decrement(const param : int; const s : indiceStorage) : indiceFullReturn is \nblock { skip } with ((nil: list(operation)), s - param)\n\nfunction sendValue(const param : unit; const s : indiceStorage) : indiceFullReturn is \nblock { \n    const c_opt : option(contract(int)) = Tezos.get_entrypoint_opt("%receiveValue", Tezos.sender);\n    const receiver : contract(int) = case c_opt of\n    | Some(c) -> c\n    | None -> (failwith("sender cannot receive indice value") : contract(int))\n    end;\n    const op : operation = Tezos.transaction(s, 0mutez, receiver);\n    const txs : list(operation) = list [ op; ];\n } with (txs, s)\n\nfunction indiceMain(const ep : indiceEntrypoints; const store : indiceStorage) : indiceFullReturn is\nblock { \n    const ret : indiceFullReturn = case ep of \n    | Increment(p) -> increment(p, store)\n    | Decrement(p) -> decrement(p, store)\n    | SendValue(p) -> sendValue(p, store)\n    end;\n    \n } with ret\n')),(0,o.kt)("h4",{id:"simulation"},"Simulation"),(0,o.kt)("p",null,"Let's simulate the indice contract with the increment action using ",(0,o.kt)("inlineCode",{parentName:"p"},"5")," as a parameter and initial storage of ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo dry-run indice.ligo indiceMain 'Increment(5)' '0'\n")),(0,o.kt)("p",null,"This should return:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"( LIST_EMPTY(), 5 )\n")),(0,o.kt)("p",null,"As expected, there is an empty list of operations, and the storage has been incremented by 5."),(0,o.kt)("p",null,"To be sure let's modify the initial value of the storage to ",(0,o.kt)("inlineCode",{parentName:"p"},"4"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo dry-run indice.ligo indiceMain 'Increment(5)' '4'\n")),(0,o.kt)("p",null,"This should return:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"( LIST_EMPTY(), 9 )\n")),(0,o.kt)("p",null,"Let's simulate another entrypoint, ",(0,o.kt)("inlineCode",{parentName:"p"},"sendValue"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo dry-run indice.ligo indiceMain 'SendValue(unit)' '3'\n")),(0,o.kt)("p",null,"This command should return:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'failwith("sender cannot receive indice value")\n')),(0,o.kt)("p",null,"This is because the contract is not deployed yet. This is the limit of this simulation."),(0,o.kt)("h4",{id:"compilation"},"Compilation"),(0,o.kt)("p",null,"Now, let's prepare the parameters and the storage."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile-storage indice.ligo indiceMain '0'\n#output: 0\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile-parameter indice.ligo indiceMain 'Increment(5)'\n#output: (Left (Right 5))\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile-parameter indice.ligo indiceMain 'Decrement(5)'\n#output: (Left (Left 5))\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile-parameter indice.ligo indiceMain 'SendValue(unit)'\n#output: (Right Unit)\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Reminder:")," ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"(Left (Right 5))"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"(Left (Left 5))"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"(Right Unit)")," are Michelson expressions that can also be used as parameters in ",(0,o.kt)("inlineCode",{parentName:"p"},"tezos-client")," command lines.")),(0,o.kt)("p",null,"We can now compile the main function and save the output in an ",(0,o.kt)("inlineCode",{parentName:"p"},"indice.tz")," file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile-contract indice.ligo indiceMain > indice.tz\n")),(0,o.kt)("p",null,"This should return:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'{ parameter (or (or (int %decrement) (int %increment)) (unit %sendValue)) ;\n  storage int ;\n  code { DUP ;\n         CDR ;\n         SWAP ;\n         CAR ;\n         IF_LEFT\n           { IF_LEFT\n               { SWAP ; SUB ; NIL operation ; PAIR }\n               { ADD ; NIL operation ; PAIR } }\n           { DROP ;\n             SENDER ;\n             CONTRACT %receiveValue int ;\n             IF_NONE { PUSH string "sender cannot receive indice value" ; FAILWITH } {} ;\n             PUSH mutez 0 ;\n             DIG 2 ;\n             DUP ;\n             DUG 3 ;\n             TRANSFER_TOKENS ;\n             SWAP ;\n             NIL operation ;\n             DIG 2 ;\n             CONS ;\n             PAIR } } }\n')),(0,o.kt)("h4",{id:"deployment"},"Deployment"),(0,o.kt)("p",null,"To display the list of deployed contracts, run the following command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client list known contracts\n")),(0,o.kt)("p",null,"This should return something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"activator: tz1TGu6TN5GSez2ndXXeDX6LgUDvLzPLqgYV\nbootstrap5: tz1ddb9NMYHZi5UzPdzTZMYQQZoMub195zgv\nbootstrap3: tz1b7tUupMgCNw2cCLpKTkSD1NZzB5TkP2sv\nbootstrap2: tz1faswCTDciRzE4oJ9jn2Vm2dvjeyA9fUzU\nbootstrap1: tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx\n")),(0,o.kt)("p",null,"Note that in the sandboxed mode, some users automatically created so we can easily use them."),(0,o.kt)("p",null,"It's time to deploy the indice smart contract."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client originate contract indice transferring 1 from bootstrap1  running 'indice.tz' --init '0' --dry-run\n")),(0,o.kt)("p",null,"You may have an error message telling you to specify the gaz fee with ",(0,o.kt)("inlineCode",{parentName:"p"},"--burn-cap"),". If everything works properly, run the same command without the ",(0,o.kt)("inlineCode",{parentName:"p"},"--dry-run")," part."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client originate contract indice transferring 1 from bootstrap1  running 'indice.tz' --init '0' --burn-cap 0.12525\n")),(0,o.kt)("p",null,"The transaction is now launched, and you should have the following response:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Node is boostrapped.\nEstimated gas 2306,275 units (will add 100 + 88 for safety)\nEstimated storage: 501 bytes added (will add 20 for safety)\nOperation successfully injected in the node.\nOperation hash is 'opR766cSqn37L8qCjgcEqu4tfGeukCKBezpHjjicAYB4NYf6g2b'\nWaiting for the operation to be included...\n")),(0,o.kt)("p",null,"Let's open another terminal in order to bake this transaction using the following command line:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client bake for bootstrap1\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Tezos baking")," is the process of signing and appending a block of transactions to the Tezos blockchain.")),(0,o.kt)("p",null,"Now, run the command below and see your indice contract on the list."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client list known contracts\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"indice: KT1D99kSAsGuLNmT1CAZWx51vgvJpzSQuoZn\nactivator: tz1TGu6TN5GSez2ndXXeDX6LgUDvLzPLqgYV\nbootstrap5: tz1ddb9NMYHZi5UzPdzTZMYQQZoMub195zgv\nbootstrap3: tz1b7tUupMgCNw2cCLpKTkSD1NZzB5TkP2sv\nbootstrap2: tz1faswCTDciRzE4oJ9jn2Vm2dvjeyA9fUzU\nbootstrap1: tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx\n")),(0,o.kt)("p",null,"Write down your indice contract address somewhere because you will need it to initialize your advisor contract."),(0,o.kt)("h3",{id:"advisor-contract"},"Advisor contract"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'//advisor.ligo\n#include "advisor_types.ligo"\n\nfunction request(const p : unit; const s : advisorStorage) : advisorFullReturn is\nblock { \n    const c_opt : option(contract(unit)) = Tezos.get_entrypoint_opt("%sendValue", s.indiceAddress);\n    const receiver : contract(unit) = case c_opt of\n    | Some(c) -> c\n    | None -> (failwith("indice cannot send its value") : contract(unit))\n    end;\n    const op : operation = Tezos.transaction(unit, 0mutez, receiver);\n    const txs : list(operation) = list [ op; ];\n } with (txs, s)\n\nfunction execute(const indiceVal : int; const s : advisorStorage) : advisorFullReturn is\nblock { \n    s.result := s.algorithm(indiceVal)\n } with ((nil : list(operation)), s)\n\n\nfunction change(const p : advisorAlgo; const s : advisorStorage) : advisorFullReturn is\nblock { \n    s.algorithm := p;\n } with ((nil : list(operation)), s)\n\nfunction advisorMain(const ep : advisorEntrypoints; const store : advisorStorage) : advisorFullReturn is\nblock { \n    const ret : advisorFullReturn = case ep of \n    | ReceiveValue(p) -> execute(p, store)\n    | RequestValue(p) -> request(p, store)\n    | ChangeAlgorithm(p) -> change(p, store)\n    end;\n } with ret\n')),(0,o.kt)("h4",{id:"simulation-1"},"Simulation"),(0,o.kt)("p",null,"Let's simulate the advisor contract with an initial storage of:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},'record[indiceAddress=("KT1D99kSAsGuLNmT1CAZWx51vgvJpzSQuoZn" : address); algorithm=(function(const i : int) is False); result=False]'),"."),(0,o.kt)("p",null,"Note that we choose a simple algorithm function that is ",(0,o.kt)("inlineCode",{parentName:"p"},"function(const i : int) is False")," therefore the saved result is ",(0,o.kt)("inlineCode",{parentName:"p"},"False")," too."),(0,o.kt)("p",null,"Let's simulate again with ",(0,o.kt)("inlineCode",{parentName:"p"},"ReceiveValue(5)")," as an action."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo dry-run advisor.ligo advisorMain 'ReceiveValue(5)' 'record[indiceAddress=(\"KT1D99kSAsGuLNmT1CAZWx51vgvJpzSQuoZn\" : address); algorithm=(function(const i : int) is False); result=False];'\n")),(0,o.kt)("p",null,"Let's simulate with ",(0,o.kt)("inlineCode",{parentName:"p"},"RequestValue(unit)")," as an action."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo dry-run advisor.ligo advisorMain 'RequestValue(unit)' 'record[indiceAddress=(\"KT1D99kSAsGuLNmT1CAZWx51vgvJpzSQuoZn\" : address); algorithm=(function(const i : int) is False); result=False]'\n")),(0,o.kt)("p",null,"Let's simulate with ",(0,o.kt)("inlineCode",{parentName:"p"},"ChangeAlgorithm(function(const i : int) is if i < 10 then True else False)")," as action."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo dry-run advisor.ligo advisorMain 'ReceiveValue(5)' 'record[indiceAddress=(\"KT1D99kSAsGuLNmT1CAZWx51vgvJpzSQuoZn\" : address); algorithm=(function(const i : int) is False); result=False]'\n")),(0,o.kt)("h4",{id:"compilation-1"},"Compilation"),(0,o.kt)("p",null,"Now, let's prepare the parameters and the storage."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile-parameter advisor.ligo advisorMain 'ReceiveValue(5)'\n#output: (Left (Right 5))\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile-parameter advisor.ligo advisorMain 'RequestValue(unit)'\n#output: (Right Unit)\n")),(0,o.kt)("p",null,"Let's say we want to change the algorithm to a more interesting one while still using a simple business logic:\n",(0,o.kt)("em",{parentName:"p"},"if the indice of a stock (indice storage) is under 20, one should invest"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile-parameter advisor.ligo advisorMain 'ChangeAlgorithm(function(const i : int) is if i < 20 then True else False)'\n#output: (Left (Left { PUSH int 20 ; SWAP ; COMPARE ; LT ; IF { PUSH bool True ] [ PUSH bool False } }))\n")),(0,o.kt)("p",null,"Let's compile the storage with a similar business logic as an initial state."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile-storage advisor.ligo advisorMain 'record[indiceAddress=(\"KT1D99kSAsGuLNmT1CAZWx51vgvJpzSQuoZn\" : address); algorithm=(function(const i : int) is if i < 10 then True else False); result=False]'\n")),(0,o.kt)("p",null,"This command should return:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'(Pair (Pair { PUSH int 10 ;\n              SWAP ;\n              COMPARE ;\n              LT ;\n              IF { PUSH bool True ] [ PUSH bool False } }\n            "KT1D99kSAsGuLNmT1CAZWx51vgvJpzSQuoZn")\n      False) \n')),(0,o.kt)("p",null,"Once everything looks ok, we can compile the main function and save the output in an ",(0,o.kt)("inlineCode",{parentName:"p"},"advisor.tz")," file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile-contract advisor.ligo indiceMain > advisor.tz\n")),(0,o.kt)("p",null,"This should return:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'{ parameter\n    (or (or (lambda %changeAlgorithm int bool) (int %receiveValue)) (unit %requestValue)) ;\n  storage\n    (pair (pair (lambda %algorithm int bool) (address %indiceAddress)) (bool %result)) ;\n  code { DUP ;\n         CDR ;\n         SWAP ;\n         CAR ;\n         IF_LEFT\n           { IF_LEFT\n               { SWAP ;\n                 DUP ;\n                 DUG 2 ;\n                 CDR ;\n                 DIG 2 ;\n                 CAR ;\n                 CDR ;\n                 DIG 2 ;\n                 PAIR ;\n                 PAIR ;\n                 NIL operation ;\n                 PAIR }\n               { SWAP ;\n                 DUP ;\n                 DUG 2 ;\n                 CAR ;\n                 CAR ;\n                 SWAP ;\n                 EXEC ;\n                 SWAP ;\n                 CAR ;\n                 PAIR ;\n                 NIL operation ;\n                 PAIR } }\n           { DROP ;\n             DUP ;\n             CAR ;\n             CDR ;\n             CONTRACT %sendValue unit ;\n             IF_NONE { PUSH string "indice cannot send its value" ; FAILWITH } {} ;\n             PUSH mutez 0 ;\n             UNIT ;\n             TRANSFER_TOKENS ;\n             SWAP ;\n             NIL operation ;\n             DIG 2 ;\n             CONS ;\n             PAIR } } }\n')),(0,o.kt)("h4",{id:"deployment-1"},"Deployment"),(0,o.kt)("p",null,"As we did for the ",(0,o.kt)("em",{parentName:"p"},"indice")," contract, let's run the following command in a ",(0,o.kt)("inlineCode",{parentName:"p"},"--dry-run")," mode. In the ",(0,o.kt)("inlineCode",{parentName:"p"},"--init")," section we put the ",(0,o.kt)("em",{parentName:"p"},"Michelson")," result of the ",(0,o.kt)("inlineCode",{parentName:"p"},"compile-storage")," that we just ran above."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client originate contract advisor transferring 1 from bootstrap1  running 'advisor.tz' --init '(Pair (Pair { PUSH int 10 ; SWAP ; COMPARE ; LT ; IF { PUSH bool True } { PUSH bool False } } \"KT1D99kSAsGuLNmT1CAZWx51vgvJpzSQuoZn\") False)' --dry-run\n")),(0,o.kt)("p",null,"You may have an error message telling you to specify the gaz fee with ",(0,o.kt)("inlineCode",{parentName:"p"},"--burn-cap"),". Try again and if everything works properly, run the same command without the ",(0,o.kt)("inlineCode",{parentName:"p"},"--dry-run")," part."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client originate contract advisor transferring 1 from bootstrap1  running 'advisor.tz' --init '(Pair (Pair { PUSH int 10 ; SWAP ; COMPARE ; LT ; IF { PUSH bool True } { PUSH bool False } } \"KT1D99kSAsGuLNmT1CAZWx51vgvJpzSQuoZn\") False)' --burn-cap 0.16825\n")),(0,o.kt)("p",null,"The transaction is now launched, and you should have the following response:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Node is boostrapped.\nEstimated gas 3144,273 units (will add 100 + 112 for safety)\nEstimated storage: 673 bytes added (will add 20 for safety)\nOperation successfully injected in the node.\nOperation hash is 'opR766cSqn37L8qCjgcEqu4tfGeukCKBezpHjjicAYB4NYf6g2b'\nWaiting for the operation to be included...\n")),(0,o.kt)("p",null,"Let's open another initialized terminal in order to bake this transaction using the following command line:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client bake for bootstrap1\n")),(0,o.kt)("p",null,"Now, run the command below to see your advisor contract on the list."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client list known contracts\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"advisor: KT1FzbmriX7zNuKh6wTiRQidk9eyb7zFsk6c\nindice: KT1D99kSAsGuLNmT1CAZWx51vgvJpzSQuoZn\nactivator: tz1TGu6TN5GSez2ndXXeDX6LgUDvLzPLqgYV\nbootstrap5: tz1ddb9NMYHZi5UzPdzTZMYQQZoMub195zgv\nbootstrap3: tz1b7tUupMgCNw2cCLpKTkSD1NZzB5TkP2sv\nbootstrap2: tz1faswCTDciRzE4oJ9jn2Vm2dvjeyA9fUzU\nbootstrap1: tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx\n")),(0,o.kt)("h3",{id:"use"},"Use"),(0,o.kt)("p",null,"Now that the two contracts are deployed, we are able to use them. You can run the following command to access the storage of the indicated contract."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client get contract storage for advisor\n")),(0,o.kt)("p",null,"This should return the same result as the ",(0,o.kt)("inlineCode",{parentName:"p"},"compile-storage")," command, because no transaction has been made so far."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'(Pair (Pair { PUSH int 10 ;\n              SWAP ;\n              COMPARE ;\n              LT ;\n              IF { PUSH bool True ] [ PUSH bool False } }\n            "KT1D99kSAsGuLNmT1CAZWx51vgvJpzSQuoZn")\n      False) \n')),(0,o.kt)("p",null,"Let's check for the ",(0,o.kt)("em",{parentName:"p"},"indice")," contract as well."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client get contract storage for indice\n//output: 0\n")),(0,o.kt)("p",null,"Now, let's make a transaction. Imagine the user ",(0,o.kt)("strong",{parentName:"p"},"bootstrap3")," wants to use the advisor smart contract to know if he should invest. For that, he must make a transaction using the action ",(0,o.kt)("inlineCode",{parentName:"p"},"RequestValue(Unit)")," for which the Michelson expression is ",(0,o.kt)("inlineCode",{parentName:"p"},"(Right Unit)"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client transfer 0 from bootstrap3 to advisor --arg '(Right Unit)'\n")),(0,o.kt)("p",null,"Then in another terminal, let's bake for ",(0,o.kt)("strong",{parentName:"p"},"bootstrap3"),","),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client bake for bootstrap3\n")),(0,o.kt)("p",null,"Now let's check if it is worth investment by looking at the storage."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client get contract storage for advisor\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'(Pair (Pair { PUSH int 10 ;\n              SWAP ;\n              COMPARE ;\n              LT ;\n              IF { PUSH bool True ] [ PUSH bool False } }\n            "KT1D99kSAsGuLNmT1CAZWx51vgvJpzSQuoZn")\n      True) \n')),(0,o.kt)("p",null,"The result changes from ",(0,o.kt)("inlineCode",{parentName:"p"},"False")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"True")," in the result field if it is worth investing. This is the case here because the initial value of the indice storage is still ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," and our algorithm will returns ",(0,o.kt)("em",{parentName:"p"},"True")," if this value is under ",(0,o.kt)("inlineCode",{parentName:"p"},"10"),"."),(0,o.kt)("p",null,"Now, it is your turn to play with these two smart contracts by incrementing the indice storage or changing the advisor algorithm."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Remember: if you are not sure what you are doing, add ",(0,o.kt)("inlineCode",{parentName:"p"},"--dry-run")," at the end of the command line to see if everything is ok.")),(0,o.kt)("p",null,"To go further, you can find the code with a video explanation of this on our ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/frankhillard/ligo_tutorial_fundadvisor"},"Github"),"."))}u.isMDXComponent=!0},4469:function(e,n,t){n.Z=t.p+"assets/images/schema_fundadvisor-83a31c2702fd7f0837979e69df054db2.svg"}}]);