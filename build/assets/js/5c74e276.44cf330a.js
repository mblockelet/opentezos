"use strict";(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[7157],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return d}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(a),d=i,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||r;return a?n.createElement(h,o(o({ref:t},c),{},{components:a})):n.createElement(h,o({ref:t},c))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},5405:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return c},default:function(){return u}});var n=a(7462),i=a(3366),r=(a(7294),a(3905)),o=["components"],s={id:"gadt-coq",title:"Coq, GADT and Mi-Cho-Coq",authors:"Frank Hillard"},l=void 0,p={unversionedId:"formal-verification/gadt-coq",id:"formal-verification/gadt-coq",title:"Coq, GADT and Mi-Cho-Coq",description:"To better understand formal verification, let's first describe the theory and tools behind the formal analysis.",source:"@site/docs/formal-verification/gadt-coq.md",sourceDirName:"formal-verification",slug:"/formal-verification/gadt-coq",permalink:"/formal-verification/gadt-coq",editUrl:"https://gitlab.com/tezos-paris-hub/opentezos/-/blob/main/docs/formal-verification/gadt-coq.md",tags:[],version:"current",lastUpdatedBy:"Aymeric",lastUpdatedAt:1628108608,formattedLastUpdatedAt:"8/4/2021",frontMatter:{id:"gadt-coq",title:"Coq, GADT and Mi-Cho-Coq",authors:"Frank Hillard"}},c=[{value:"Type theory",id:"type-theory",children:[],level:3},{value:"Coq",id:"coq",children:[{value:"CoC - CiC",id:"coc---cic",children:[],level:4},{value:"Gallina (Term and Vernacular)",id:"gallina-term-and-vernacular",children:[],level:4}],level:3},{value:"GADT",id:"gadt",children:[{value:"Algebraic Data Type",id:"algebraic-data-type",children:[],level:4},{value:"Example with Michelson pairs and variants",id:"example-with-michelson-pairs-and-variants",children:[],level:4},{value:"A semi-ring to generalize Michelson language",id:"a-semi-ring-to-generalize-michelson-language",children:[],level:4}],level:3},{value:"Mi-Cho-Coq",id:"mi-cho-coq",children:[{value:"Type system",id:"type-system",children:[],level:4},{value:"Syntax",id:"syntax",children:[],level:4},{value:"Semantics",id:"semantics",children:[],level:4}],level:3},{value:"Conclusion",id:"conclusion",children:[],level:2},{value:"References",id:"references",children:[{value:"Category theory",id:"category-theory",children:[{value:"Monad",id:"monad",children:[],level:4}],level:3}],level:2}],m={toc:c};function u(e){var t=e.components,a=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"To better understand formal verification, let's first describe the theory and tools behind the formal analysis."),(0,r.kt)("p",null,"In order to perform a formal verification, we need a ",(0,r.kt)("em",{parentName:"p"},"proof assistant"),". ",(0,r.kt)("em",{parentName:"p"},"Coq")," is a proof assistant which can be used for formal verification on Tezos smart contracts. Other proof assistants can also be used such as ",(0,r.kt)("em",{parentName:"p"},"Archetype")," or ",(0,r.kt)("em",{parentName:"p"},"K-framework"),". But in this section, we will focus on ",(0,r.kt)("em",{parentName:"p"},"Coq")," which provides a language (",(0,r.kt)("em",{parentName:"p"},"Gallina"),") for defining theorems and for proving these theorems. The proof process relies on:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A theory (i.e. a base foundation of mathematic): We will introduce a branch of mathematics called ",(0,r.kt)("strong",{parentName:"p"},"Type theory"),", and more specifically, the ",(0,r.kt)("em",{parentName:"p"},"Calculus of Construction")," (CoC), the building principle of ",(0,r.kt)("em",{parentName:"p"},"Coq"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"An expression of the Michelson language as a formal definition: We use ",(0,r.kt)("em",{parentName:"p"},"GADT")," for the theory and ",(0,r.kt)("em",{parentName:"p"},"Mi-Cho-Coq")," in practice.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A formalization of the Michelson script (code of the smart contract) into a theorem to prove this theorem (we'll see this in the next ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/modeling-theorem"},"chapter"),")."))),(0,r.kt)("p",null,"The goal is to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"provide a solid type-checking mechanism of a Michelson script based on formal rules.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"ensure the semantic of the script by verifying post-conditions (in the next ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/modeling-theorem"},"section"),")."))),(0,r.kt)("p",null,"This section intends to give:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a theoretical context about the mathematical principles (CoC, CiC) used in the formal proof process of ",(0,r.kt)("em",{parentName:"li"},"Coq")),(0,r.kt)("li",{parentName:"ul"},"a bit of insight on how a language is designed with a ",(0,r.kt)("em",{parentName:"li"},"GADT")),(0,r.kt)("li",{parentName:"ul"},"a brief description of the ",(0,r.kt)("em",{parentName:"li"},"Coq")," proof assistant"),(0,r.kt)("li",{parentName:"ul"},"a brief description of ",(0,r.kt)("em",{parentName:"li"},"Mi-Cho-Coq")," (library for ",(0,r.kt)("em",{parentName:"li"},"Coq"),")")),(0,r.kt)("p",null,"For a good understanding of this theoretical part, it is recommended to have some notions on first-order and second-order logic ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/gadt-coq#references"},"[10]"),", mathematics (e.g. set, group, monoid, associativity, distributivity, reflexivity), functional programming, and language theory."),(0,r.kt)("h3",{id:"type-theory"},"Type theory"),(0,r.kt)("p",null,"In mathematics, logic and computer science, a ",(0,r.kt)("em",{parentName:"p"},"type system")," is a formal system in which every term has a ",(0,r.kt)("strong",{parentName:"p"},"type"),". The type defines the meaning and the operations that can be performed on it. ",(0,r.kt)("strong",{parentName:"p"},"Type theory")," is the academic study of type systems."),(0,r.kt)("p",null,"Type theory is closely linked to many fields of active research, including the Curry\u2013Howard correspondence ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/gadt-coq#references"},"[6] [7]")," that provides a deep isomorphism between ",(0,r.kt)("em",{parentName:"p"},"intuitionistic logic"),", typed ",(0,r.kt)("em",{parentName:"p"},"\u03bb-calculus")," and ",(0,r.kt)("em",{parentName:"p"},"cartesian closed categories"),". "),(0,r.kt)("p",null,"Some Type theories serve as alternatives to set theory as a foundation of mathematics. Two famous theories are ",(0,r.kt)("em",{parentName:"p"},"Alonzo Church's typed \u03bb-calculus")," and ",(0,r.kt)("em",{parentName:"p"},"Per Martin-L\xf6f's intuitionistic type theory"),". The ",(0,r.kt)("em",{parentName:"p"},"Per Martin-L\xf6f's intuitionistic type theory")," has been the foundation of constructive mathematics. For instance, Thierry Coquand's ",(0,r.kt)("strong",{parentName:"p"},"Calculus of constructions")," and its derivatives are the foundation used by ",(0,r.kt)("strong",{parentName:"p"},"Coq")," (the proof assistant) ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/gadt-coq#references"},"[1]"),"."),(0,r.kt)("h3",{id:"coq"},"Coq"),(0,r.kt)("p",null,"Initially developed by Thierry Coquand, ",(0,r.kt)("em",{parentName:"p"},"Coq")," ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/gadt-coq#references"},"[1]")," is a proof assistant, designed to develop mathematical proofs and especially made to write formal specifications, programs, and proofs that programs comply with their specifications. "),(0,r.kt)("p",null,"Specifications, programs, and proofs are formalized in the ",(0,r.kt)("em",{parentName:"p"},"Coq")," language called ",(0,r.kt)("em",{parentName:"p"},"Gallina"),", which follows the ",(0,r.kt)("em",{parentName:"p"},"Calculus of Inductive Constructions")," (CIC)."),(0,r.kt)("p",null,"A program is a sequence of instructions in a language. ",(0,r.kt)("em",{parentName:"p"},"Coq")," is a generic tool and can support many languages (e.g. Mi-Cho-Coq is a library for Michelson language support). A program represents ",(0,r.kt)("strong",{parentName:"p"},"how")," a modification is applied.\nThe specification of a program represents ",(0,r.kt)("strong",{parentName:"p"},"what")," a program is meant to do. ",(0,r.kt)("em",{parentName:"p"},"Coq")," provides a language (called Gallina -Terms) for modelling logical objects such as theorems, axioms, assumptions). The proof is a sequence of logical deductions (based on axioms, assumptions and the inference rule) that verify the ",(0,r.kt)("strong",{parentName:"p"},"compliance of a program to its specification"),"."),(0,r.kt)("h4",{id:"coc---cic"},"CoC - CiC"),(0,r.kt)("p",null,"Initially developed by Thierry Coquand, the ",(0,r.kt)("em",{parentName:"p"},"Calculus of Constructions")," ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/gadt-coq#references"},"[13]")," (or CoC) is a typed high-order ",(0,r.kt)("em",{parentName:"p"},"\u03bb-calculus")," (i.e. a typed formal system taking the logic of second-order into account). The CoC is used as a typed programming language. "),(0,r.kt)("p",null,"Many derivatives of CoC have been created to handle inductive types, predicates and co-inductive types. The CIC (",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/gadt-coq#references"},"[18]"),") is an extension of CoC which integrates inductive datatype. The ",(0,r.kt)("em",{parentName:"p"},"Coq")," proof assistant is built upon CiC."),(0,r.kt)("p",null,"All logical judgments in Coq are typing judgments: the very heart of ",(0,r.kt)("em",{parentName:"p"},"Coq")," is, in fact, a type-checking algorithm. "),(0,r.kt)("p",null,"An interesting additional feature of ",(0,r.kt)("em",{parentName:"p"},"Coq")," is that it can automatically extract executable programs from specifications, either as ",(0,r.kt)("em",{parentName:"p"},"OCaml")," or as ",(0,r.kt)("em",{parentName:"p"},"Haskell")," source code."),(0,r.kt)("h4",{id:"gallina-term-and-vernacular"},"Gallina (Term and Vernacular)"),(0,r.kt)("p",null,"Logical objects (such as theorems, axioms) are formalized in Gallina-Term language, and proof scripts are formalized in Gallina-Vernacular language, which provides ",(0,r.kt)("em",{parentName:"p"},"tactics"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Coq")," inference engine executes the proof script. In the case of a Tezos smart contract, the inference engine relies on the Coq universe and the ",(0,r.kt)("em",{parentName:"p"},"Mi-Cho-Coq")," library. "),(0,r.kt)("p",null,"For more information about the CoC and CiC foundation, it is recommended to read the official paper from Thierry Coquand and other documentation ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/gadt-coq#references"},"[13] [16] [18]"),". It is required to know the basis of \u03bb-calculus ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/gadt-coq#references"},"[17]")," in order to understand mathematical notations used in CoC and CiC."),(0,r.kt)("h3",{id:"gadt"},"GADT"),(0,r.kt)("p",null,"Generalized algebraic data type (GADT) is a generalization of parametric algebraic data types (i.e. a standard representation of algebraic data types)."),(0,r.kt)("p",null,"The idea of ",(0,r.kt)("strong",{parentName:"p"},"algebraic data types")," is to define a language as a composite type and formalize an algebra of data types (like the algebra on numbers). The programming language can be seen as a complex-type with functors."),(0,r.kt)("p",null,"An essential application of GADTs is to embed ",(0,r.kt)("strong",{parentName:"p"},"higher-order abstract syntax")," in a type-safe fashion."),(0,r.kt)("p",null,"In computer science, ",(0,r.kt)("strong",{parentName:"p"},"higher-order abstract syntax")," (abbreviated HOAS) is a technique for the representation of abstract syntax trees for languages with variable binders. "),(0,r.kt)("p",null,"This article ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/gadt-coq#references"},"[8]")," describes how to define an ",(0,r.kt)("strong",{parentName:"p"},"higher-order abstract syntax")," in ",(0,r.kt)("em",{parentName:"p"},"Coq")," (i.e., defining axioms, and inductive types).\nGADT is similar to inductive families of data types (or inductive data types) found in ",(0,r.kt)("em",{parentName:"p"},"Coq"),"'s CIC ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/gadt-coq#references"},"[18]"),"."),(0,r.kt)("h4",{id:"algebraic-data-type"},"Algebraic Data Type"),(0,r.kt)("p",null,"In computer programming, and especially functional programming and type theory, an ",(0,r.kt)("strong",{parentName:"p"},"algebraic data type")," is a kind of composite type, (i.e., a type formed by combining other types)."),(0,r.kt)("p",null,"Two common classes of algebraic types are product types (i.e., tuples and records) and sum types (i.e., tagged or disjoint unions, coproduct types or variant types)."),(0,r.kt)("p",null,"The values of a product type typically contain several values, called ",(0,r.kt)("strong",{parentName:"p"},"fields"),". All values of that type have the same combination of field types. The set of all possible values of a product type is the set-theoretic product, i.e., the Cartesian product, of the sets of all possible values of its field types."),(0,r.kt)("p",null,"The values of a sum type are typically grouped into several classes, called ",(0,r.kt)("strong",{parentName:"p"},"variants"),". A value of a variant type is created with a quasi-functional entity called a constructor. Each variant has its own constructor, which takes a specified number of arguments with specified types. The set of all possible values of a sum type is the set-theoretic sum, i.e., the disjoint union, of the sets of all possible values of its variants.  "),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Algebraic Data Type")," (ADT) formalizes a language into a composite type and describes possible operations on data types."),(0,r.kt)("h4",{id:"example-with-michelson-pairs-and-variants"},"Example with Michelson pairs and variants"),(0,r.kt)("p",null,"Let's illustrate the ADT formalization by defining a set with PRODUCT (a product type) and SUM (a sum type) thus forming a ",(0,r.kt)("em",{parentName:"p"},"semi-ring")," that can model Michelson language structures (",(0,r.kt)("em",{parentName:"p"},"Pairs")," and ",(0,r.kt)("em",{parentName:"p"},"Variants"),"). Defining Michelson data structures as an ADT provides a robust type-checking mechanism on Michelson scripts."),(0,r.kt)("p",null,"The Michelson language can be modelled as a mathematical object (set) with a set of rules (PRODUCT and SUM) describing possible operations on datatypes. "),(0,r.kt)("p",null,"PRODUCT type = ",(0,r.kt)("inlineCode",{parentName:"p"},"(a b)")," (i.e., Michelson pair)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"reflexivity: (up to an isomorphism) ",(0,r.kt)("em",{parentName:"li"},"swap"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"(a b) ~ (b a)")),(0,r.kt)("li",{parentName:"ul"},"associativity: (up to an isomorphism) ",(0,r.kt)("em",{parentName:"li"},"assoc"),":  ",(0,r.kt)("inlineCode",{parentName:"li"},"((a, b), c) ~ (a, (b, c))")),(0,r.kt)("li",{parentName:"ul"},"neutral element: (up to an isomorphism) ",(0,r.kt)("em",{parentName:"li"},"first"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"(a,()) ~ a"))),(0,r.kt)("p",null,"Programmatically speaking, a tuple ",(0,r.kt)("inlineCode",{parentName:"p"},"(int bool)")," does not match a tuple ",(0,r.kt)("inlineCode",{parentName:"p"},"(bool int)"),', but both contain the same information. These two tuples are equivalent up to an isomorphism (which is the function "swap"; i.e. ',(0,r.kt)("inlineCode",{parentName:"p"},"swap x = (snd x, fst x)"),"). Notice that the inverse function of ",(0,r.kt)("em",{parentName:"p"},"swap")," is ",(0,r.kt)("em",{parentName:"p"},"swap"),". Also ",(0,r.kt)("em",{parentName:"p"},"assoc")," and ",(0,r.kt)("em",{parentName:"p"},"first")," are invertible (up to an isomorphism)."),(0,r.kt)("p",null,"SUM type = (Either a b); ",(0,r.kt)("inlineCode",{parentName:"p"},"Either a b = Left a | Right b")," (i.e. variant)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"reflexivity: ",(0,r.kt)("inlineCode",{parentName:"li"},"Either a b ~ Either b a")," "),(0,r.kt)("li",{parentName:"ul"},"neutral element (",(0,r.kt)("inlineCode",{parentName:"li"},"Void"),"): ",(0,r.kt)("inlineCode",{parentName:"li"},"Either a Void ~ a")," (there is no element in the set Void) equivalent to ",(0,r.kt)("inlineCode",{parentName:"li"},"a + 0 = a")),(0,r.kt)("li",{parentName:"ul"},"associativity: (i.e. ",(0,r.kt)("inlineCode",{parentName:"li"},"triple (a b c) = Left a | Right c | Middle b"),")"),(0,r.kt)("li",{parentName:"ul"},"distributivity: ",(0,r.kt)("inlineCode",{parentName:"li"},"(a,Either(b,c)) ~ Either (a,b) (a,c)")," is equivalent to ",(0,r.kt)("inlineCode",{parentName:"li"},"(a * (b + c) = a*b + a*c)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(a, Void) ~ Void")," is equivalent to ",(0,r.kt)("inlineCode",{parentName:"li"},"a * 0 = 0"))),(0,r.kt)("p",null,'Notice that the variant ("Either" concept) can be combined with pairs due to the distributivity rule.\nFor the PRODUCT type, properties (associativity, distributivity) are respected up to an isomorphism that is invertible (i.e., an inverse function exists for each isomorphism). '),(0,r.kt)("p",null,'For example, the "triple" function compose a variant from three elements. The function "triple_inv" decompose a triple in a nested pair containing the three elements: ',(0,r.kt)("inlineCode",{parentName:"p"},"triple_inv x = ((Left(x) Middle(x)) Right(x))"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"triple (a (b c)) = Left a | Right c | Middle b"),"."),(0,r.kt)("p",null,"So, a set equipped with PRODUCT and SUM represents a language equipped with ",(0,r.kt)("em",{parentName:"p"},"pairs")," and ",(0,r.kt)("em",{parentName:"p"},"variants")," (such as Michelson language). "),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Other language structures such as ",(0,r.kt)("em",{parentName:"p"},"List")," can be defined using the ",(0,r.kt)("em",{parentName:"p"},"List Monad pattern"),".  ")),(0,r.kt)("h4",{id:"a-semi-ring-to-generalize-michelson-language"},"A semi-ring to generalize Michelson language"),(0,r.kt)("p",null,"In algebra, a set equipped with PRODUCT and SUM is a semi-ring. Notice that the inverse of SUM has no meaning (subtraction ",(0,r.kt)("inlineCode",{parentName:"p"},"a - b")," is not permitted; programmatically speaking, removing an integer from a structure that has no integer field has no meaning). That's why the set equipped with PRODUCT and SUM is just a semi-ring and not a ring (due to the missing relation ",(0,r.kt)("inlineCode",{parentName:"p"},"a + inv(a) ~ Void")," where ",(0,r.kt)("inlineCode",{parentName:"p"},"inv(a)")," does not exist)."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Formally speaking, a ring is an ",(0,r.kt)("em",{parentName:"p"},"abelian")," group whose operation is called ",(0,r.kt)("em",{parentName:"p"},"addition"),", with a second binary operation called ",(0,r.kt)("em",{parentName:"p"},"multiplication")," that is associative, distributive over the ",(0,r.kt)("em",{parentName:"p"},"addition")," operation, and has a multiplicative identity element. ")),(0,r.kt)("p",null,"In mathematics, ",(0,r.kt)("strong",{parentName:"p"},"rings are algebraic structures that generalize fields"),": multiplication need not be commutative and multiplicative inverses do not have to exist. In other words, a ring is a set equipped with two binary operations satisfying properties analogous to those of addition and multiplication of integers. Ring elements may be numbers, such as integers or complex numbers, but they may also be non-numerical objects, such as polynomial numbers or functions."),(0,r.kt)("p",null,"To conclude, the formalization of a language into an algebra of data types (ADT) allows to specify a mathematical representation of a language; and thus allows you to use CoC principles to prove theorems on this algebra (i.e., verifying a script in this language). The ",(0,r.kt)("strong",{parentName:"p"},"Mi-Cho-Coq")," library is the formal ",(0,r.kt)("em",{parentName:"p"},"Coq")," representation of the Michelson language and allows to specify a formal representation of a Tezos smart contract."),(0,r.kt)("h3",{id:"mi-cho-coq"},"Mi-Cho-Coq"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Mi-Cho-Coq")," library represents the bridge between Tezos smart contracts and formal proofs in Coq."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Mi-Cho-Coq")," library ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/gadt-coq#references"},"[2]")," is a formalization of the Michelson language ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/gadt-coq#references"},"[9]")," using the Coq interactive theorem prover ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/gadt-coq#references"},"[1]"),"."),(0,r.kt)("p",null,"In practice, the ",(0,r.kt)("em",{parentName:"p"},"Mi-Cho-Coq"),' library is used to produce a formal definition of a Michelson script (i.e., the "Modeling theorem" ',(0,r.kt)("a",{parentName:"p",href:"/formal-verification/modeling-theorem#Example_vote"},"section"),"). Each Michelson instruction has its equivalent in the ",(0,r.kt)("em",{parentName:"p"},"Mi-Cho-Coq")," library (e.g. see the syntax ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/gadt-coq#Syntax"},"subsection"),")."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Mi-Cho-Coq")," library provides a formal definition (in Gallina) of the ",(0,r.kt)("strong",{parentName:"p"},"type system")," (Michelson types), the ",(0,r.kt)("strong",{parentName:"p"},"syntax")," (instructions of the Michelson), the ",(0,r.kt)("strong",{parentName:"p"},"semantics")," (evaluator) and the lexing and parsing (for type-checking)."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"It is recommended to have notions of ",(0,r.kt)("em",{parentName:"p"},"Language theory")," in order to understand the following Mi-Cho-Coq definition (grammar rules).")),(0,r.kt)("h4",{id:"type-system"},"Type system"),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"type system")," consists in the definition of types (comparable types and non-comparable ones)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Inductive simple_comparable_type : Set :=\n| string\n| nat\n| int\n| bytes\n...\n\nInductive comparable_type : Set :=\n| Comparable_type_simple : simple_comparable_type -> comparable_type\n| Cpair : simple_comparable_type -> comparable_type -> comparable_type.\n\nInductive type : Set :=\n| Comparable_type (_ : simple_comparable_type)\n| key\n| unit\n| signature\n| option (a : type)\n| list (a : type)\n| set (a : comparable_type)\n| contract (a : type)\n| operation\n| pair (a : type) (b : type)\n| or (a : type) (_ : annot_o) (b : type) (_ : annot_o)\n| lambda (a b : type)\n| map (k : comparable_type) (v : type)\n| big_map (k : comparable_type) (v : type)\n| chain_id.\n")),(0,r.kt)("h4",{id:"syntax"},"Syntax"),(0,r.kt)("p",null,"The *",(0,r.kt)("strong",{parentName:"p"},"*syntax")," and typing of Michelson instructions are formalized as a dependent inductive type to rule out ill-typed instructions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Inductive instruction :\n  forall (self_type : Datatypes.option type) (tail_fail_flag : Datatypes.bool) (A B : Datatypes.list type), Set :=\n| NOOP {A} : instruction A A\n| FAILWITH {A B a} : instruction (a ::: A) B\n| SEQ {A B C} : instruction A B -> instruction B C -> instruction A C\n| IF_ {A B} : instruction A B -> instruction A B -> instruction (bool ::: A) B\n| LOOP {A} : instruction A (bool ::: A) -> instruction (bool ::: A) A\n...\n")),(0,r.kt)("p",null,"Notice that the inductive type ",(0,r.kt)("inlineCode",{parentName:"p"},"instruction"),"  defines typing rules for each instruction (",(0,r.kt)("inlineCode",{parentName:"p"},"SEQ"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"IF"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"LOOP"),", ...)."),(0,r.kt)("h4",{id:"semantics"},"Semantics"),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"semantics")," of types is defined by interpreting them with predefined ",(0,r.kt)("em",{parentName:"p"},"Coq")," types (e.g. int -> Z, nat -> N, mutez -> int63). The semantics of Michelson is defined by an evaluator ",(0,r.kt)("inlineCode",{parentName:"p"},"eval")," formalized as a ",(0,r.kt)("em",{parentName:"p"},"Fixpoint"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Fixpoint eval {self_type} {tff} {env} {A : stack_type} {B : stack_type}\n         (i : instruction self_type tff A B) (fuel : Datatypes.nat) {struct fuel} :\n  stack A -> M (stack B) :=\n  match fuel with\n  | O => fun SA => Failed _ Out_of_fuel\n  | S n =>\n    match i, SA, env with\n    | FAILWITH, (x, _), _ => Failed _ (Assertion_Failure _ x)\n    | NOOP, SA, _ => Return SA\n    | DUP, (x, SA), _ => Return (x, (x, SA))\n    | SWAP, (x, (y, SA)), _ => Return (y, (x, SA))\n    | PUSH a x, SA, _ => Return (concrete_data_to_data _ x, SA)\n    | UNIT, SA, _ => Return (tt, SA)\n    | LAMBDA a b code, SA, _ => Return (existT _ _ code, SA)\n    | EQ, (x, SA), _ => Return ((x =? 0)%Z, SA)\n    | NEQ, (x, SA), _ => Return (negb (x =? 0)%Z, SA)\n    | LT, (x, SA), _ => Return ((x <? 0)%Z, SA)\n        | SEQ B C, SA, env => \n        let! r := eval env B n SA in\n        eval env C n r\n    | IF_ bt bf, (b, SA), env =>\n        if b then eval env bt n SA else eval env bf n SA\n    | LOOP body, (b, SA), env =>\n        if b then eval env (body;; (LOOP body)) n SA else Return SA\n...\n")),(0,r.kt)("p",null,"Notice that the evaluator defines actions that must be performed for each type of instruction."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Since evaluating a Michelson instruction might fail (whereas ",(0,r.kt)("em",{parentName:"p"},"Coq")," functions cannot), the return type of this evaluator is wrapped in an exception monad (handling errors such as overflow, lexing, parsing, fuel).")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Coq forbids non-terminating functions, so we use a common ",(0,r.kt)("em",{parentName:"p"},"Coq")," trick to define the evaluator on diverging instructions such as ",(0,r.kt)("em",{parentName:"p"},"LOOP"),": we make the evaluator structurally recursive on an extra argument of type Datatypes.nat called the ",(0,r.kt)("strong",{parentName:"p"},"fuel")," of the evaluator.")),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"Proof assistants are built upon the Calculus of Construction, a branch of the Type theory. ",(0,r.kt)("em",{parentName:"p"},"Coq")," is proof assistant and can be seen as a formal engine."),(0,r.kt)("p",null,"We saw how the Michelson language can be represented as an Algebraic Data Type (GADT) by giving an example of building a semi-ring for representing ",(0,r.kt)("em",{parentName:"p"},"pairs")," and ",(0,r.kt)("em",{parentName:"p"},"variants"),". "),(0,r.kt)("p",null,"Mi-Cho-Coq is a GADT formalizing the Michelson language (data structures and instructions (a formal definition for each) and is used in combination with ",(0,r.kt)("em",{parentName:"p"},"Coq")," to verify a Michelson script."),(0,r.kt)("p",null,"Coq and Mi-Cho-Coq are the tools allowing the formal verification of Tezos smart contract. Other similar tools can be used such as Archetype or K-framework.  "),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("p",null,"[1]"," Coq - ",(0,r.kt)("a",{parentName:"p",href:"https://coq.inria.fr/distrib/current/refman/index.html"},"https://coq.inria.fr/distrib/current/refman/index.html")),(0,r.kt)("p",null,"[2]"," Mi-cho-coq repository - ",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.com/nomadic-labs/mi-cho-coq"},"https://gitlab.com/nomadic-labs/mi-cho-coq")),(0,r.kt)("p",null,"[3]"," Introduction to Coq - ",(0,r.kt)("a",{parentName:"p",href:"http://www-sop.inria.fr/members/Yves.Bertot/courses/introcoq.pdf"},"http://www-sop.inria.fr/members/Yves.Bertot/courses/introcoq.pdf")),(0,r.kt)("p",null,"[4]"," Gallina - ",(0,r.kt)("a",{parentName:"p",href:"https://coq.inria.fr/distrib/current/refman/language/gallina-specification-language.html"},"https://coq.inria.fr/distrib/current/refman/language/gallina-specification-language.html")),(0,r.kt)("p",null,"[5]"," Lambda-Calculus and Isomorphism Curry-Howard - ",(0,r.kt)("a",{parentName:"p",href:"http://disi.unitn.it/~bernardi/RSISE11/Papers/curry-howard.pdf"},"http://disi.unitn.it/~bernardi/RSISE11/Papers/curry-howard.pdf")),(0,r.kt)("p",null,"[6]"," Isomorphism Curry-Howard for Dummies - ",(0,r.kt)("a",{parentName:"p",href:"https://www.p%C3%A9drot.fr/slides/inria-junior-02-15.pdf"},"https://www.p\xe9drot.fr/slides/inria-junior-02-15.pdf")),(0,r.kt)("p",null,"[7]"," Isomorphism Curry-Howard (small) - ",(0,r.kt)("a",{parentName:"p",href:"https://www.seas.harvard.edu/courses/cs152/2015sp/lectures/lec15-curryhoward.pdf"},"https://www.seas.harvard.edu/courses/cs152/2015sp/lectures/lec15-curryhoward.pdf")),(0,r.kt)("p",null,"[8]"," Higher-order abstract syntax in Coq - ",(0,r.kt)("a",{parentName:"p",href:"https://web.archive.org/web/20060830033826/http://www.site.uottawa.ca/~afelty/dist/tlca95.ps"},"https://web.archive.org/web/20060830033826/http://www.site.uottawa.ca/~afelty/dist/tlca95.ps")),(0,r.kt)("p",null,"[9]"," Michelson - ",(0,r.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/michelson-reference/"},"https://tezos.gitlab.io/michelson-reference/")),(0,r.kt)("p",null,"[10]"," Logique formelle - ",(0,r.kt)("a",{parentName:"p",href:"https://www.irif.fr/~roziere/2ord/2ndordre.pdf"},"https://www.irif.fr/~roziere/2ord/2ndordre.pdf")),(0,r.kt)("p",null,"[12]"," Axioms de Peano - ",(0,r.kt)("a",{parentName:"p",href:"https://fr.wikipedia.org/wiki/Axiomes_de_Peano"},"https://fr.wikipedia.org/wiki/Axiomes_de_Peano")),(0,r.kt)("p",null,"[13]"," Calculus of constructions - ",(0,r.kt)("a",{parentName:"p",href:"https://fr.wikipedia.org/wiki/Calcul_des_constructions"},"https://fr.wikipedia.org/wiki/Calcul_des_constructions")),(0,r.kt)("p",null,"[14]"," Mini-guide Coq - ",(0,r.kt)("a",{parentName:"p",href:"https://www.lri.fr/~paulin/MathInfo/coq-survey.pdf"},"https://www.lri.fr/~paulin/MathInfo/coq-survey.pdf")),(0,r.kt)("p",null,"[15]"," Coq\u2019Art - ",(0,r.kt)("a",{parentName:"p",href:"https://www.labri.fr/perso/casteran/CoqArt/coqartF.pdf"},"https://www.labri.fr/perso/casteran/CoqArt/coqartF.pdf")),(0,r.kt)("p",null,"[16]"," The calculus of constructions (1988) by Thierry Coquand - ",(0,r.kt)("a",{parentName:"p",href:"https://www.sciencedirect.com/science/article/pii/0890540188900053"},"https://www.sciencedirect.com/science/article/pii/0890540188900053")),(0,r.kt)("p",null,"[17]"," Lambda-calcul - ",(0,r.kt)("a",{parentName:"p",href:"https://fr.wikipedia.org/wiki/Lambda-calcul"},"https://fr.wikipedia.org/wiki/Lambda-calcul")),(0,r.kt)("p",null,"[18]"," Calculus of Inductive Constructions - ",(0,r.kt)("a",{parentName:"p",href:"https://coq.inria.fr/distrib/current/refman/language/cic.html"},"https://coq.inria.fr/distrib/current/refman/language/cic.html")),(0,r.kt)("p",null,"[19]"," Michelson - ",(0,r.kt)("a",{parentName:"p",href:"https://www.michelson-lang.com/why-michelson.html"},"https://www.michelson-lang.com/why-michelson.html")),(0,r.kt)("p",null,"[20]"," Vote example - ",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.com/nomadic-labs/mi-cho-coq/-/blob/master/src/contracts_coq/vote.v"},"https://gitlab.com/nomadic-labs/mi-cho-coq/-/blob/master/src/contracts_coq/vote.v")),(0,r.kt)("h1",{id:"annexe"},"ANNEXE"),(0,r.kt)("h3",{id:"category-theory"},"Category theory"),(0,r.kt)("p",null,"Category theory formalizes mathematical structure and its concepts in terms of a labelled directed graph called a category, whose nodes are called objects, and whose labelled directed edges are called ",(0,r.kt)("em",{parentName:"p"},"arrows")," (or morphisms). A category has two basic properties: the ability to compose the arrows associatively, and the existence of an identity arrow for each object. The language of category theory has been used to formalize concepts of other high-level abstractions such as ",(0,r.kt)("em",{parentName:"p"},"sets"),", ",(0,r.kt)("em",{parentName:"p"},"rings"),", and ",(0,r.kt)("em",{parentName:"p"},"groups"),". Informally, category theory is a general theory of functions. "),(0,r.kt)("p",null,"The common usage of \"type theory\" is when those types are used with a term rewrite system. The most famous early example is Alonzo Church's simply typed lambda calculus. Church's theory of types helped the formal system avoid the Kleene\u2013Rosser paradox that afflicted the original untyped lambda calculus. Church demonstrated that it could serve as a foundation of mathematics and it was referred to as a ",(0,r.kt)("strong",{parentName:"p"},"higher-order logic"),"."),(0,r.kt)("p",null,"In ",(0,r.kt)("strong",{parentName:"p"},"category theory"),", a category is ",(0,r.kt)("strong",{parentName:"p"},"Cartesian closed")," if, roughly speaking, any morphism defined on a product of two objects can be naturally identified with a morphism defined on one of the factors. These categories are particularly important in mathematical logic and the theory of programming, in that their internal language is the ",(0,r.kt)("strong",{parentName:"p"},"simply typed lambda calculus"),". They are generalized by closed monoidal categories, whose internal language, linear type systems, are suitable for both quantum and classical computation."),(0,r.kt)("p",null," Here is an embedding of the ",(0,r.kt)("strong",{parentName:"p"},"simply typed lambda calculus")," with an arbitrary collection of base types, tuples and a fixed point combinator: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"data Lam :: * -> * where\n  Lift :: a                     -> Lam a        // lifted value\n  Pair :: Lam a -> Lam b        -> Lam (a, b)   // product\n  Lam  :: (Lam a -> Lam b)      -> Lam (a -> b) // lambda abstraction\n  App  :: Lam (a -> b) -> Lam a -> Lam b        // function application\n  Fix  :: Lam (a -> a)          -> Lam a        // fixed point\n")),(0,r.kt)("p",null,"A fixed point of a function is a value that is mapped to itself by the function. In combinatory logic for computer science, a fixed-point combinator (or fixpoint combinator) is a higher-order function ",(0,r.kt)("em",{parentName:"p"},"fix")," that returns some fixed point of its argument function, if one exists."),(0,r.kt)("h4",{id:"monad"},"Monad"),(0,r.kt)("p",null,"In category theory, a monad (also triple, triad, standard construction and fundamental construction) is an endofunctor (a functor mapping a category to itself), together with two natural transformations required to fulfil certain coherence conditions. Monads are used in the theory of pairs of adjoint functors, and they generalize closure operators on partially ordered sets to arbitrary categories. "),(0,r.kt)("p",null,"In functional programming, a ",(0,r.kt)("strong",{parentName:"p"},"monad")," is an abstraction that allows structuring programs generically. Supporting languages may use monads to abstract away boilerplate code needed by the program logic. Monads achieve this by providing their own data type, which represents a specific form of computation, along with two procedures:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"One to wrap values of any basic type within the monad (yielding a ",(0,r.kt)("strong",{parentName:"li"},"monadic value"),");"),(0,r.kt)("li",{parentName:"ul"},"Another to compose functions that output monadic values (called ",(0,r.kt)("strong",{parentName:"li"},"monadic functions"),")")),(0,r.kt)("p",null,"This allows monads to simplify a wide range of problems, like handling potential undefined values (with the Maybe monad), or keeping values within a flexible, well-formed list (using the List monad). With a monad, a programmer can turn a complicated sequence of functions into a succinct pipeline that abstracts away auxiliary data management, control flow, or side-effects."),(0,r.kt)("p",null,"Without getting too much into mathematics, in programming a Monad is a Design Pattern. It\u2019s a structure, a wrapper which \u201cenriches\u201d a value by giving it a context."),(0,r.kt)("p",null,"//TODO ...\nIt's about having representations simulating exactly notions such as exceptions and side-effects while keeping the purety of functionnal languages."),(0,r.kt)("p",null,"Famous examples of Monads are:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Option/Maybe monad (it can represent a missing/null value)\nEither monad (it can represent a successful operation or a failure)\nIO/Effect monad (it can represent side-effects)\nTask monad (it can represent asynchronous side-effects)\n")))}u.isMDXComponent=!0}}]);