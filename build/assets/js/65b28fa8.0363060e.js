"use strict";(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[4278],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),h=i,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||o;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2912:function(e,t,n){n.d(t,{Z:function(){return o}});var a=n(7294),i="root_2W3B",o=function(e){var t=e.children;return a.createElement("div",{className:i},t)}},6934:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return u}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),r=(n(2912),["components"]),s={id:"3-buy-ticket",title:"Buy ticket",authors:"Maxime Sallerin and Benjamin Pilia"},l=void 0,c={unversionedId:"ligo/write-contract-ligo/3-buy-ticket",id:"ligo/write-contract-ligo/3-buy-ticket",title:"Buy ticket",description:"Smart Contract development: Buy ticket entrypoint",source:"@site/docs/ligo/write-contract-ligo/3-buy-ticket.md",sourceDirName:"ligo/write-contract-ligo",slug:"/ligo/write-contract-ligo/3-buy-ticket",permalink:"/opentezos/ligo/write-contract-ligo/3-buy-ticket",editUrl:"https://gitlab.com/tezos-paris-hub/opentezos/-/blob/main/docs/ligo/write-contract-ligo/3-buy-ticket.md",tags:[],version:"current",lastUpdatedBy:"Damien ZONDA",lastUpdatedAt:1646498958,formattedLastUpdatedAt:"3/5/2022",sidebarPosition:3,frontMatter:{id:"3-buy-ticket",title:"Buy ticket",authors:"Maxime Sallerin and Benjamin Pilia"},sidebar:"docs",previous:{title:"Launch raffle",permalink:"/opentezos/ligo/write-contract-ligo/2-launch-raffle"},next:{title:"Close raffle",permalink:"/opentezos/ligo/write-contract-ligo/4-close-raffle"}},p=[{value:"Smart Contract development: Buy ticket entrypoint",id:"smart-contract-development-buy-ticket-entrypoint",children:[{value:"LIGO concepts used in this part: collections",id:"ligo-concepts-used-in-this-part-collections",children:[{value:"Lists",id:"lists",children:[],level:4},{value:"Sets",id:"sets",children:[],level:4},{value:"Maps",id:"maps",children:[],level:4}],level:3},{value:"Customizing the Raffle storage",id:"customizing-the-raffle-storage",children:[],level:3},{value:"Adding the BuyTicket entrypoint",id:"adding-the-buyticket-entrypoint",children:[],level:3},{value:"Implementing the BuyTicket logic",id:"implementing-the-buyticket-logic",children:[],level:3}],level:2}],d={toc:p};function u(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"smart-contract-development-buy-ticket-entrypoint"},"Smart Contract development: Buy ticket entrypoint"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"LIGO concepts used in this part:\nwith this second entrypoint, we will need to register players and map a raffle ticket to each player. Thus, we will learn how to use collections.\nIt will also be the opportunity for you to review functions and checks")),(0,o.kt)("p",null,"The second entrypoint can be freely called by everyone who wants to buy a ticket. In our use case, each address can only buy one ticket, which costs 1 Tez."),(0,o.kt)("p",null,"Two additional variables have to be stored:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"who is taking part in the raffle"),(0,o.kt)("li",{parentName:"ol"},"who owns a ticket")),(0,o.kt)("p",null,"The storage has to be modified. Collections are going to come in handy for the modification of the storage"),(0,o.kt)("h3",{id:"ligo-concepts-used-in-this-part-collections"},"LIGO concepts used in this part: collections"),(0,o.kt)("h4",{id:"lists"},"Lists"),(0,o.kt)("p",null,"Lists are ",(0,o.kt)("strong",{parentName:"p"},"linear collections of elements of the same type"),". Linear means that in order to reach an element in a list, all the elements before have to be browsed (sequentially accessed). Elements can be repeated as only their order in the collection matters. The first element is called the ",(0,o.kt)("inlineCode",{parentName:"p"},"head"),", and the sub-list after the head is called the ",(0,o.kt)("inlineCode",{parentName:"p"},"tail"),"."),(0,o.kt)("p",null,"Lists are used for returning operations from a smart contract's main function and to store the same values several times in a collection"),(0,o.kt)("p",null,"For more details, see the ",(0,o.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/language-basics/sets-lists-tuples#lists"},"Ligolang ",(0,o.kt)("inlineCode",{parentName:"a"},"list")," documentation")),(0,o.kt)("h4",{id:"sets"},"Sets"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Sets")," are ",(0,o.kt)("strong",{parentName:"p"},"unordered collections of values of the same type")," (as opposed to lists which are ordered collections).\nLike the mathematical ",(0,o.kt)("em",{parentName:"p"},"sets")," and ",(0,o.kt)("em",{parentName:"p"},"lists"),", ",(0,o.kt)("em",{parentName:"p"},"sets")," can be empty and, if not, elements of ",(0,o.kt)("em",{parentName:"p"},"sets")," in LIGO are unique, even though they can be repeated in a ",(0,o.kt)("em",{parentName:"p"},"list"),"."),(0,o.kt)("p",null,"For more details, see the ",(0,o.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/language-basics/sets-lists-tuples#sets"},"Ligolang ",(0,o.kt)("inlineCode",{parentName:"a"},"set")," documentation")),(0,o.kt)("h4",{id:"maps"},"Maps"),(0,o.kt)("p",null,"A ",(0,o.kt)("em",{parentName:"p"},"Map")," is a data structure that associates a value to a key, thus creating a key-value binding. All keys have the same type and all values have the same type. An additional requirement is that the type of the keys must be comparable."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Maps load their entries into the environment, which is fine for small maps, but for maps holding millions of entries, the cost of loading them would be too expensive. For this we use ",(0,o.kt)("inlineCode",{parentName:"p"},"big_maps"),". Their syntax is the same as for regular maps, but they are optimized for a huge number of entries.")),(0,o.kt)("p",null,"For more details, see the ",(0,o.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/language-basics/maps-records#maps"},"Ligolang ",(0,o.kt)("inlineCode",{parentName:"a"},"map")," documentation")," and ",(0,o.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/language-basics/maps-records#big-maps"},"Ligolang ",(0,o.kt)("inlineCode",{parentName:"a"},"big map")," documentation")," "),(0,o.kt)("h3",{id:"customizing-the-raffle-storage"},"Customizing the Raffle storage"),(0,o.kt)("p",null,"Thanks to these collections, the second entrypoint of the Raffle smart contract can be implemented. A list of participants must be stored, as well as the ticket/owner pair."),(0,o.kt)("p",null,"Two new variables will be stored in the contract storage."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"What collection should be used for:"),(0,o.kt)("ol",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ol"},"the participants (who can only buy one ticket)?"),(0,o.kt)("li",{parentName:"ol"},"the tickets and their owner?"))),(0,o.kt)("p",null,"For the first point, two collections could be used: a list and a set. Since the participants can only buy one ticket, a ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," is the right choice (since each element cannot appear twice)."),(0,o.kt)("p",null,"For the second point, each ticket should be mapped to its owner. The number of participants is not limited: there might be millions of them, so a ",(0,o.kt)("inlineCode",{parentName:"p"},"big map")," seems the right choice."),(0,o.kt)("p",null,"The set of participants should a have set of addresses, while the big map should map a ticket id (a nat) to an address. The new storage is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type storage is record [\n    admin : address;\n    close_date : timestamp;\n    jackpot : tez;\n    description : string;\n    raffle_is_open : bool;\n    players : set (address);\n    sold_tickets : big_map (nat, address);\n  ]\n")),(0,o.kt)("h3",{id:"adding-the-buyticket-entrypoint"},"Adding the BuyTicket entrypoint"),(0,o.kt)("p",null,"The smart contract needs to expose an entrypoint to buy tickets. The method is the same as the one detailed for the first entrypoint:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Define the type parameter. This type should be ",(0,o.kt)("inlineCode",{parentName:"li"},"unit")," since the buyer does not get to choose the ticket id:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type buyTicketParameter is unit\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Adding the entrypoint in the variant:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type raffleEntrypoints is\n| OpenRaffle of openRaffleParameter\n| BuyTicket of buyTicketParameter\n")),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"Handling the new entrypoint in the control flow:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function main (const action : raffleEntrypoints; const store : storage): returnType is\n  case action of [\n    | OpenRaffle (param) -> open_raffle (param.0, param.1, param.2, store)\n    | BuyTicket (param) -> buy_ticket(param, store)\n  ];\n")),(0,o.kt)("h3",{id:"implementing-the-buyticket-logic"},"Implementing the BuyTicket logic"),(0,o.kt)("p",null,"The last step is to implement the logic of this entrypoint. Just as for the first entrypoint, this logic will be implemented in a function, ",(0,o.kt)("inlineCode",{parentName:"p"},"buy_ticket"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function buy_ticket (const param: unit; const store : storage) : returnType is {\n  skip\n} with ((nil : list (operation)), store)\n")),(0,o.kt)("p",null,"Two variables have to be checked:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"is the buyer sending the right amount of tez?"),(0,o.kt)("li",{parentName:"ol"},"has the buyer not already bought a ticket?")),(0,o.kt)("p",null,"For the first point, this is the same check that is done for the first entrypoint. Checking if an address is calling the entrypoint for the first time (= a buyer cannot buy more than one ticket) means checking if the calling address is already in the payers ",(0,o.kt)("inlineCode",{parentName:"p"},"set"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function buy_ticket (const param: unit; const store : storage) : returnType is {\n  if store.raffle_is_open then {\n    const ticket_price : tez = 1tez;\n    const current_player : address = Tezos.sender;\n    if Tezos.amount <> ticket_price\n    then failwith("The sender did not send the right tez amount.")\n    else {\n      if store.players contains current_player\n      then failwith("Each player can participate only once.")\n      else {\n        skip\n      }\n    }\n  } else {\n    failwith("The raffle is closed.")\n  }\n} with ((nil : list (operation)), store)\n')),(0,o.kt)("p",null,"Once these two checks have been performed, the buyer can receive a ticket. For this, the entrypoint needs to:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"register the address of a participant. The address must be added into the players set from the storage."),(0,o.kt)("li",{parentName:"ol"},"create a raffle ticket id. Since each participant can only buy a single ticket, the size of the participants set gives the new ticket id."),(0,o.kt)("li",{parentName:"ol"},"associate the ticket with its owner. The new ticket id will be a map to the buyer in the ",(0,o.kt)("inlineCode",{parentName:"li"},"sold_tickets")," big map.")),(0,o.kt)("p",null,"These three steps use the methods described in the collections section."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"const store")," has been replaced by ",(0,o.kt)("inlineCode",{parentName:"p"},"var store")," because it is modified.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"const param")," has been replaced by ",(0,o.kt)("inlineCode",{parentName:"p"},"const _param"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"_")," is used when a variable is unused.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function buy_ticket (const param: unit; var store : storage) : returnType is {\n  if store.raffle_is_open then {\n    const ticket_price : tez = 1tez;\n    const current_player : address = Tezos.sender;\n    if Tezos.amount =/= ticket_price\n    then failwith("The sender did not send the right tez amount.")\n    else {\n      if store.players contains current_player\n      then failwith("Each player can participate only once.")\n      else {\n        const ticket_id : nat = Set.size(store.players);\n        store.players := Set.add(current_player, store.players);\n        store.sold_tickets[ticket_id] := current_player;\n      }\n    }\n  } else {\n    failwith("The raffle is closed.")\n  }\n} with ((nil : list (operation)), store)\n')),(0,o.kt)("p",null,"Our contract now is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'type openRaffleParameter is tez * timestamp * option(string)\ntype buyTicketParameter is unit\n\ntype raffleEntrypoints is\n  | OpenRaffle of openRaffleParameter\n  | BuyTicket of buyTicketParameter\n\ntype storage is record [\n    admin : address;\n    close_date : timestamp;\n    jackpot : tez;\n    description : string;\n    raffle_is_open : bool;\n    players : set (address);\n    sold_tickets : big_map (nat, address);\n  ]\n\ntype returnType is list (operation) * storage\n\nfunction open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option (string); var store : storage) : returnType is {\n  if Tezos.source =/= store.admin\n  then failwith ("Administrator not recognized.")\n  else {\n    if not store.raffle_is_open then {\n      if Tezos.amount < jackpot_amount\n      then failwith ("The administrator does not own enough tz.")\n      else {\n        const today : timestamp = Tezos.now;\n        const seven_day : int = 7 * 86400;\n        const in_7_day : timestamp = today + seven_day;\n        const is_close_date_not_valid : bool = close_date < in_7_day;\n        if is_close_date_not_valid\n        then failwith("The raffle must remain open for at least 7 days.")\n        else {\n          patch store with record [\n            jackpot = jackpot_amount;\n            close_date = close_date;\n            raffle_is_open = True;\n          ];\n\n          case description of [\n          | Some(d) -> patch store with record [description=d]\n          | None -> {skip}\n          ]\n        }\n      }\n    }\n    else {\n      failwith ("A raffle is already open.")\n    }\n  }\n} with ((nil : list (operation)), store)\n\nfunction buy_ticket (const _param: unit; var store : storage) : returnType is {\n  if store.raffle_is_open then {\n    const ticket_price : tez = 1tez;\n    const current_player : address = Tezos.sender;\n    if Tezos.amount =/= ticket_price\n    then failwith("The sender did not send the right tez amount.")\n    else {\n      if store.players contains current_player\n      then failwith("Each player can participate only once.")\n      else {\n        const ticket_id : nat = Set.size(store.players);\n        store.players := Set.add(current_player, store.players);\n        store.sold_tickets[ticket_id] := current_player;\n      }\n    }\n  } else {\n    failwith("The raffle is closed.")\n  }\n} with ((nil : list (operation)), store)\n\nfunction main (const action : raffleEntrypoints; const store : storage): returnType is\n  case action of [\n    | OpenRaffle (param) -> open_raffle (param.0, param.1, param.2, store)\n    | BuyTicket (param) -> buy_ticket(param, store)\n  ]\n')))}u.isMDXComponent=!0}}]);