"use strict";(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[5432],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return f}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),f=o,h=u["".concat(s,".").concat(f)]||u[f]||d[f]||i;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2912:function(e,t,n){n.d(t,{Z:function(){return i}});var a=n(7294),o="root_2W3B",i=function(e){var t=e.children;return a.createElement("div",{className:o},t)}},9250:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return u}});var a=n(7462),o=n(3366),i=(n(7294),n(3905)),r=(n(2912),["components"]),l={id:"2-launch-raffle",title:"Launch raffle",authors:"Maxime Sallerin and Benjamin Pilia"},s=void 0,p={unversionedId:"ligo/write-contract-ligo/2-launch-raffle",id:"ligo/write-contract-ligo/2-launch-raffle",title:"Launch raffle",description:"Smart Contract development: launch raffle entrypoint",source:"@site/docs/ligo/write-contract-ligo/2-launch-raffle.md",sourceDirName:"ligo/write-contract-ligo",slug:"/ligo/write-contract-ligo/2-launch-raffle",permalink:"/opentezos/ligo/write-contract-ligo/2-launch-raffle",editUrl:"https://gitlab.com/tezos-paris-hub/opentezos/-/blob/main/docs/ligo/write-contract-ligo/2-launch-raffle.md",tags:[],version:"current",lastUpdatedBy:"Damien ZONDA",lastUpdatedAt:1646498958,formattedLastUpdatedAt:"3/5/2022",sidebarPosition:2,frontMatter:{id:"2-launch-raffle",title:"Launch raffle",authors:"Maxime Sallerin and Benjamin Pilia"},sidebar:"docs",previous:{title:"Raffle contract",permalink:"/opentezos/ligo/write-contract-ligo/1-raffle-contract"},next:{title:"Buy ticket",permalink:"/opentezos/ligo/write-contract-ligo/3-buy-ticket"}},c=[{value:"Smart Contract development: launch raffle entrypoint",id:"smart-contract-development-launch-raffle-entrypoint",children:[{value:"LIGO concepts used in this part",id:"ligo-concepts-used-in-this-part",children:[{value:"Records",id:"records",children:[],level:4},{value:"Tuples",id:"tuples",children:[],level:4},{value:"Conditional branching",id:"conditional-branching",children:[],level:4},{value:"Error handling",id:"error-handling",children:[],level:4},{value:"Interactions with a Tezos network: Tezos Module",id:"interactions-with-a-tezos-network-tezos-module",children:[],level:4},{value:"Functions in ligo",id:"functions-in-ligo",children:[{value:"Block functions",id:"block-functions",children:[],level:5},{value:"Blockless functions",id:"blockless-functions",children:[],level:5}],level:4},{value:"Dispatching the control flow in the main function",id:"dispatching-the-control-flow-in-the-main-function",children:[{value:"Variant type",id:"variant-type",children:[],level:5},{value:"Pattern Matching (Variant type handling)",id:"pattern-matching-variant-type-handling",children:[],level:5}],level:4}],level:3},{value:"Customizing the Raffle storage",id:"customizing-the-raffle-storage",children:[],level:3},{value:"Creating a raffle session: entrypoint definition",id:"creating-a-raffle-session-entrypoint-definition",children:[],level:3},{value:"Adding the OpenRaffle logic",id:"adding-the-openraffle-logic",children:[],level:3}],level:2}],d={toc:c};function u(e){var t=e.components,n=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"smart-contract-development-launch-raffle-entrypoint"},"Smart Contract development: launch raffle entrypoint"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"LIGO concepts used in this part:\nWe are going to add our first entrypoint. We will need to dispatch the control flow in the main function. We are also going to complexify the storage with new types. Finally, we are going to implement some logic, check the access rights, raise an exception if they are not respected, and interact with some part of the Tezos blockchain. We will use:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"Record"),(0,i.kt)("li",{parentName:"ul"},"Tuples"),(0,i.kt)("li",{parentName:"ul"},"functions"),(0,i.kt)("li",{parentName:"ul"},"Entrypoint"),(0,i.kt)("li",{parentName:"ul"},"variant"),(0,i.kt)("li",{parentName:"ul"},"pattern matching"),(0,i.kt)("li",{parentName:"ul"},"if condition"),(0,i.kt)("li",{parentName:"ul"},"failwith"),(0,i.kt)("li",{parentName:"ul"},"types: addresses, timestamp"),(0,i.kt)("li",{parentName:"ul"},"Tezos Module"))),(0,i.kt)("p",null,"Our LIGO code is compiling but is doing nothing: It has an empty storage, no parameter, and the smart contract returns an empty list of operations and an empty storage. As detailed in the previous chapter, the smart contract should perform three actions:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"launch a raffle"),(0,i.kt)("li",{parentName:"ol"},"sell tickets (i.e., a caller can buy a ticket)"),(0,i.kt)("li",{parentName:"ol"},"close the raffle, and reward the winner")),(0,i.kt)("p",null,"Each action will be coded into an entrypoint."),(0,i.kt)("h3",{id:"ligo-concepts-used-in-this-part"},"LIGO concepts used in this part"),(0,i.kt)("h4",{id:"records"},"Records"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"record")," type is a structure that holds several variables: each variable is referenced thanks to a field name."),(0,i.kt)("p",null,"Records are used:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"for the storage definition "),(0,i.kt)("li",{parentName:"ul"},"for any object that should hold different types of information.")),(0,i.kt)("p",null,"For more details, see the ",(0,i.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/language-basics/maps-records#records"},"Ligolang ",(0,i.kt)("inlineCode",{parentName:"a"},"record")," documentation")),(0,i.kt)("h4",{id:"tuples"},"Tuples"),(0,i.kt)("p",null,"Tuples gather multiple fields into a single structure. A tuple data structure is ordered, which means we can access each tuple element by its position. Unlike ",(0,i.kt)("inlineCode",{parentName:"p"},"record")," type, the tuple fields are unnamed."),(0,i.kt)("p",null,"Tuples are used:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"for the return type of the ",(0,i.kt)("strong",{parentName:"li"},"main")," function"),(0,i.kt)("li",{parentName:"ul"},"for ordered data structures ")),(0,i.kt)("p",null,"For more details, see the ",(0,i.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/language-basics/sets-lists-tuples#tuples"},"Ligolang ",(0,i.kt)("inlineCode",{parentName:"a"},"tuple")," documentation")),(0,i.kt)("h4",{id:"conditional-branching"},"Conditional branching"),(0,i.kt)("p",null,"There are two ways to write ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," conditions:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"For a single expression:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"function isSmall (const n : nat) : bool is\nif n < 10n then true else false\n")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"For more than a simple expression we use a ",(0,i.kt)("inlineCode",{parentName:"li"},"block")," expression: ")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"if x < y then {\n  const z : nat = x;\n  x := y; y := z\n}\nelse skip\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"If a conditional has a branch ",(0,i.kt)("inlineCode",{parentName:"p"},"else skip"),", that branch can be omitted")),(0,i.kt)("p",null,"The conditional above is better written as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"if x < y then {\n  const z : nat = x;\n  x := y; y := z\n}\n")),(0,i.kt)("p",null,"For more details, see the ",(0,i.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/language-basics/boolean-if-else#conditionals"},"Ligolang ",(0,i.kt)("inlineCode",{parentName:"a"},"if")," documentation")),(0,i.kt)("h4",{id:"error-handling"},"Error handling"),(0,i.kt)("p",null,"A smart contract can raise an exception that will stop the smart contract execution with the use of the keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"failwith")," (with an error message):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"failwith(<string_message>)\n")),(0,i.kt)("p",null,"For more details, see the ",(0,i.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/language-basics/exceptions"},"Ligolang ",(0,i.kt)("inlineCode",{parentName:"a"},"failwith")," documentation")),(0,i.kt)("h4",{id:"interactions-with-a-tezos-network-tezos-module"},"Interactions with a Tezos network: Tezos Module"),(0,i.kt)("p",null,"The Tezos module is a set of LIGO instructions that query the state of the Tezos blockchain."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Tezos.balance"),": Get the balance for the contract."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Tezos.amount"),": Get the amount of Tez provided by the sender to complete this transaction."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Tezos.sender"),": Get the address that initiated the current transaction."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Tezos.self_address"),": Get the address of the currently running contract."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Tezos.source"),": Get the originator (address) of the current transaction. That is, if a chain of transactions led to an execution, you get the address that began the chain. Not to be confused with ",(0,i.kt)("inlineCode",{parentName:"li"},"Tezos.sender"),", which gives the address of the contract or user which directly caused the current transaction."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Tezos.chain_id"),": Get the identifier of the chain to distinguish between main and test chains."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Tezos.transaction"),": create a transaction that will be sent at the end of the contract execution.")),(0,i.kt)("p",null,"For more details, see the ",(0,i.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/reference/current-reference"},"Ligolang ",(0,i.kt)("inlineCode",{parentName:"a"},"Tezos module")," documentation")),(0,i.kt)("h4",{id:"functions-in-ligo"},"Functions in ligo"),(0,i.kt)("p",null,"LIGO functions are the basic building block of contracts. Each entrypoint of a contract executes a function and each smart contract must have at least one ",(0,i.kt)("strong",{parentName:"p"},"main")," function that dispatches the control flow to other functions."),(0,i.kt)("p",null,"When calling a function, LIGO makes a copy of the arguments but also of the environment variables."),(0,i.kt)("p",null,"Therefore, any modification to these will not be reflected outside the scope of the function and will be lost if they are not explicitly returned by the function."),(0,i.kt)("p",null,"There are two syntaxes for functions in PascaLigo, ",(0,i.kt)("em",{parentName:"p"},"Block Functions")," and ",(0,i.kt)("em",{parentName:"p"},"Blockless Functions"),"."),(0,i.kt)("h5",{id:"block-functions"},"Block functions"),(0,i.kt)("p",null,"Block functions in PascaLigo are defined using the following syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"function <name> (<parameters>) : <return_type> is {\n  <operations and instructions>\n} with <returned_value>\n")),(0,i.kt)("p",null,"If a placeholder is needed, the instruction ",(0,i.kt)("inlineCode",{parentName:"p"},"skip")," leaves the state unchanged. The rationale for ",(0,i.kt)("inlineCode",{parentName:"p"},"skip")," instead of a genuinely empty block is that it prevents you from writing an empty block by mistake."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"function <name> (<parameters>) : <return_type> is {\n  skip\n} with <returned_value>\n")),(0,i.kt)("h5",{id:"blockless-functions"},"Blockless functions"),(0,i.kt)("p",null,"Functions containing all of their logic into a single expression can be defined without a block. The ",(0,i.kt)("inlineCode",{parentName:"p"},"add")," function above can be re-written as a blockless function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"function add (const a: int; const b : int) : int is a + b\n")),(0,i.kt)("p",null,"For more details, see the ",(0,i.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/language-basics/functions"},"Ligolang ",(0,i.kt)("inlineCode",{parentName:"a"},"functions")," documentation")),(0,i.kt)("h4",{id:"dispatching-the-control-flow-in-the-main-function"},"Dispatching the control flow in the main function"),(0,i.kt)("p",null,"In LIGO, the design pattern is to have one ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," function that dispatches the control flow according to its parameters. The functions that can be invoked by those actions are called entrypoints. This is similar to the programming in ",(0,i.kt)("em",{parentName:"p"},"C"),"."),(0,i.kt)("p",null,"The parameter of the contract is then a ",(0,i.kt)("inlineCode",{parentName:"p"},"variant")," type (described below), and depending on the constructors of that type, different functions in the contract are called. In other terms, the main function dispatches the control flow depending on a pattern matching the contract parameter."),(0,i.kt)("h5",{id:"variant-type"},"Variant type"),(0,i.kt)("p",null,"A variant type is a user-defined or built-in type (in case of ",(0,i.kt)("inlineCode",{parentName:"p"},"options"),") that defines a type by cases. A number of cases are defined in the type definition. The value of a variable of this type must be included in these cases. The simplest variant type is equivalent to the enumerated types found in ",(0,i.kt)("em",{parentName:"p"},"Java"),", ",(0,i.kt)("em",{parentName:"p"},"C++"),", ",(0,i.kt)("em",{parentName:"p"},"JavaScript"),", etc."),(0,i.kt)("p",null,"Here is how we define a ",(0,i.kt)("inlineCode",{parentName:"p"},"bit")," as being either 1 or 0 (and nothing else):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"type bit is One | Zero\nconst closed_switch : bit = One\nconst open_switch : bit = Zero\n")),(0,i.kt)("p",null,"Entrypoints are defined within a variant type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"type entrypoints is\n| <firstEntrypoint> of <firstEntrypointParameterType>\n| <secondEntrypoint> of <secondEntrypointParameterType>\n| ...\n|  <nthEntrypoint> of <nthEntrypointParameterType>\n")),(0,i.kt)("h5",{id:"pattern-matching-variant-type-handling"},"Pattern Matching (Variant type handling)"),(0,i.kt)("p",null,"Pattern matching can be used to route the program's control flow based on the value of a ",(0,i.kt)("inlineCode",{parentName:"p"},"variant"),". It is similar to the ",(0,i.kt)("inlineCode",{parentName:"p"},"switch")," construct of many other languages. Consider for instance the definition of a power switch that turns a light on or off."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"type bit is One | Zero\n\nfunction power_switch (const b : bit) : bit is\n  case b of [\n  | One -> Zero\n  | Zero -> One\n  ]\n")),(0,i.kt)("p",null,"The control is performed this way:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"type entrypoints is\n| <firstEntrypoint> of <firstEntrypointParameterType>\n| <secondEntrypoint> of <secondEntrypointParameterType>\n| ...\n|  <nthEntrypoint> of <nthEntrypointParameterType>\n\nfunction main (const action : entrypoints; const store : storage): returnType is {\n  const return : returnType = case action [\n  | <firstEntrypoint> (param) -> <firstEntrypointFunctionName> (param.0, param.1, param.2, param.3, store)\n  | <secondEntrypoint> (param) -> <secondEntrypointFunctionName> (param, store)\n  | ...\n  | <nthEntrypoint> (param) -> <nthEntrypointFunctionName> (param, store)\n  ];\n} with return\n")),(0,i.kt)("h3",{id:"customizing-the-raffle-storage"},"Customizing the Raffle storage"),(0,i.kt)("p",null,"The first entrypoint of our Raffle smart contract illustrates the basics of PascaLigo, covered above."),(0,i.kt)("p",null,"Before coding the logic of the first action (opening a raffle session), the storage has to be modified to hold such a raffle. The contract needs an ",(0,i.kt)("strong",{parentName:"p"},"administrator"),": he will launch a raffle session, and provide a ",(0,i.kt)("strong",{parentName:"p"},"description"),". When the raffle is ",(0,i.kt)("strong",{parentName:"p"},"opened"),", it should be clearly noted in the storage. This raffle will need a ",(0,i.kt)("strong",{parentName:"p"},"reward")," and will be ongoing for a given ",(0,i.kt)("strong",{parentName:"p"},"time"),"."),(0,i.kt)("p",null,"So, five variables are needed:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the raffle administrator"),(0,i.kt)("li",{parentName:"ul"},"a description of the raffle"),(0,i.kt)("li",{parentName:"ul"},"a raffle opened boolean"),(0,i.kt)("li",{parentName:"ul"},"the reward in tez"),(0,i.kt)("li",{parentName:"ul"},"the raffle end date")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"What would be the types for each piece of information?")),(0,i.kt)("p",null,"For each variable, the corresponding type is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"raffle administrator: address"),(0,i.kt)("li",{parentName:"ul"},"raffle description: string"),(0,i.kt)("li",{parentName:"ul"},"raffle opened : boolean"),(0,i.kt)("li",{parentName:"ul"},"reward: tez"),(0,i.kt)("li",{parentName:"ul"},"raffle end date: timestamp")),(0,i.kt)("p",null,"So far, the storage was empty, thanks to the ",(0,i.kt)("inlineCode",{parentName:"p"},"unit")," type. The storage now needs to hold five variables of different types. Several values can be held in a ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),", but they must have the same type. Besides, ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," is not meant to keep the same number of elements."),(0,i.kt)("p",null,"The correct way to define a storage is to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"record")," type, as such:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"type storage is record [\n    admin : address;\n    close_date : timestamp;\n    jackpot : tez;\n    description : string;\n    raffle_is_open : bool;\n]\n")),(0,i.kt)("h3",{id:"creating-a-raffle-session-entrypoint-definition"},"Creating a raffle session: entrypoint definition"),(0,i.kt)("p",null,"The contract storage can now hold a raffle session. The contract has to provide the users with a way of creating a raffle session. To do that, it needs an entrypoint that performs such an action: this new entrypoint should be named ",(0,i.kt)("inlineCode",{parentName:"p"},"OpenRaffle")," and would allow the administrator to open a raffle."),(0,i.kt)("p",null,"So far, there is no entrypoint into this smart contract:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"type raffleEntrypoints is unit\n")),(0,i.kt)("p",null,"Adding the OpenRaffle entrypoint means defining the raffle entrypoint as a ",(0,i.kt)("inlineCode",{parentName:"p"},"variant"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"type raffleEntrypoints is OpenRaffle of unit\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"raffleEntrypoints")," is now a variant: ",(0,i.kt)("inlineCode",{parentName:"p"},"OpenRaffle")," does not expect any argument (because of ",(0,i.kt)("inlineCode",{parentName:"p"},"of unit"),")."),(0,i.kt)("p",null,"In order to be exposed, ",(0,i.kt)("inlineCode",{parentName:"p"},"OpenRaffle")," needs to be handled in a pattern matching, in the main function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"function main (const action : raffleEntrypoints; const store : storage):  list (operation) * storage is\n  case action of [\n    OpenRaffle -> ((nil: list(operation)), store)\n  ]\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Notice that the contract ",(0,i.kt)("strong",{parentName:"p"},"parameter")," (",(0,i.kt)("em",{parentName:"p"},"raffleEntrypoints")," variant) is requiring no parameter (",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),").\nFor now, this smart contract only has a single default entrypoint with no argument.\nThe ",(0,i.kt)("em",{parentName:"p"},"storage")," type is used as the second parameter of the ",(0,i.kt)("em",{parentName:"p"},"main")," function. ")),(0,i.kt)("p",null,"Our smart contract now looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"type raffleEntrypoints is OpenRaffle of unit\n\ntype storage is record [\n    admin : address;\n    close_date : timestamp;\n    jackpot : tez;\n    description : string;\n    raffle_is_open : bool;\n  ]\n\ntype returnType is list (operation) * storage\n\nfunction main (const action : raffleEntrypoints; const store : storage): returnType is\n  case action of [\n    OpenRaffle -> ((nil: list(operation)), store)\n  ]\n")),(0,i.kt)("p",null,"Despite the definition of a more complex storage, the execution of the smart contract still does nothing. The smart contract should at least require some parameters and update its storage."),(0,i.kt)("p",null,"To open a raffle, several variables have to be sent: the reward, the closing date, and a raffle description. Let's define a type for these parameters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"type openRaffleParameter is tez * timestamp * option(string)\n")),(0,i.kt)("p",null,"It is declared as a tuple:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tez"),": the amount of the reward"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"timestamp"),": closing date"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"option(string)"),": an optional description")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"OpenRaffle")," entrypoint must expect these parameters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"type openRaffleParameter is tez * timestamp * option(string)\ntype raffleEntrypoints is OpenRaffle of openRaffleParameter\n")),(0,i.kt)("p",null,"Finally, the parameters must be added in the control flow in the main function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"type openRaffleParameter is tez * timestamp * option(string)\ntype raffleEntrypoints is OpenRaffle of openRaffleParameter\n\ntype storage is record [\n    admin : address;\n    close_date : timestamp;\n    jackpot : tez;\n    description : string;\n    raffle_is_open : bool;\n  ]\n\ntype returnType is list (operation) * storage\n\nfunction main (const action : raffleEntrypoints; const store : storage): returnType is\n  case action of [\n    OpenRaffle (param) -> ((nil: list(operation)), store)\n  ]\n")),(0,i.kt)("p",null,"This outputs some Michelson code that does nothing, but there is a slight change in the parameter section:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"{ parameter (pair (pair mutez timestamp) (option string)) ;\n  storage\n    (pair (pair (pair (address %admin) (timestamp %close_date))\n                (pair (string %description) (mutez %jackpot)))\n          (bool %raffle_is_open)) ;\n  code { CDR ; NIL operation ; PAIR } }\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"openRaffleParameter")," is expected in the parameter section."),(0,i.kt)("h3",{id:"adding-the-openraffle-logic"},"Adding the OpenRaffle logic"),(0,i.kt)("p",null,"The last step is to implement the logic of this entrypoint, in a function, which will update the storage."),(0,i.kt)("p",null,"Let's create an empty function. This function expects the three needed parameters, and returns the standard list of operations and the updated store:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"function open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option(string); const store : storage) : returnType is {\n  skip\n} with ((nil: list(operation)), store)\n")),(0,i.kt)("p",null,"The first step is to check if the entrypoint is called by the administrator. If not, it should raise an exception. The check is performed by the association of an ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," condition and a ",(0,i.kt)("inlineCode",{parentName:"p"},"failwith"),". The address calling the entrypoint should match the address in the storage. This is called access control."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'function open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option(string); const store : storage) : returnType is {\n  if Tezos.source =/= store.admin\n  then failwith("administrator not recognized")\n  else {\n    skip\n  }\n} with ((nil: list(operation)), store)\n')),(0,i.kt)("p",null,"A second check has to be performed: a raffle cannot be opened if the previous one has not yet closed. A boolean gives this value in the storage: ",(0,i.kt)("inlineCode",{parentName:"p"},"raffle_is_open")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'function open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option(string); const store : storage) : returnType is {\n  if Tezos.source =/= store.admin\n  then failwith("Administrator not recognized.")\n  else {\n    if not store.raffle_is_open then {\n      skip\n    } else {\n      failwith("A raffle is already open.")\n    }\n  }\n} with ((nil: list(operation)), store)\n')),(0,i.kt)("p",null,"A third check is performed on the reward: the funds sent must match the raffle reward."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'function open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option (string); const store : storage) : returnType is {\n  if Tezos.source =/= store.admin\n  then failwith ("Administrator not recognized.")\n  else {\n    if not store.raffle_is_open then {\n      if Tezos.amount < jackpot_amount\n      then failwith ("The administrator does not own enough tez.")\n      else {\n        skip\n      }\n    }\n    else {\n      failwith ("A raffle is already open.")\n    }\n  }\n} with ((nil : list (operation)), store)\n')),(0,i.kt)("p",null,"One final check is performed on the raffle closing date: the raffle should last at least a week."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'function open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option (string); const store : storage) : returnType is {\n  if Tezos.source =/= store.admin\n  then failwith ("Administrator not recognized.")\n  else {\n    if not store.raffle_is_open then {\n      if Tezos.amount < jackpot_amount\n      then failwith ("The administrator does not own enough tez.")\n      else {\n        const today : timestamp = Tezos.now;\n        const seven_day : int = 7 * 86400;\n        const in_7_day : timestamp = today + seven_day;\n        const is_close_date_not_valid : bool = close_date < in_7_day;\n        if is_close_date_not_valid\n        then failwith("The raffle must remain open for at least 7 days.")\n        else {\n          skip\n        }\n      }\n    }\n    else {\n      failwith ("A raffle is already open.")\n    }\n  }\n} with ((nil : list (operation)), store)\n')),(0,i.kt)("p",null,"We need to store the variables about the raffle: the reward, the closing date and the raffle description. In addition, the storage should indicate that there's an ongoing raffle. The storage needs to be updated with these variables. "),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note how the description is added to the storage as an ",(0,i.kt)("inlineCode",{parentName:"p"},"option"),".")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"const store")," has been replaced by ",(0,i.kt)("inlineCode",{parentName:"p"},"var store")," because it is modified.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'function open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option (string); var store : storage) : returnType is {\n  if Tezos.source =/= store.admin\n  then failwith ("Administrator not recognized.")\n  else {\n    if not store.raffle_is_open then {\n      if Tezos.amount < jackpot_amount\n      then failwith ("The administrator does not own enough tz.")\n      else {\n        const today : timestamp = Tezos.now;\n        const seven_day : int = 7 * 86400;\n        const in_7_day : timestamp = today + seven_day;\n        const is_close_date_not_valid : bool = close_date < in_7_day;\n        if is_close_date_not_valid\n        then failwith("The raffle must remain open for at least 7 days.")\n        else {\n          patch store with record [\n            jackpot = jackpot_amount;\n            close_date = close_date;\n            raffle_is_open = True;\n          ];\n\n          case description of [\n          | Some(d) -> patch store with record [description=d]\n          | None -> {skip}\n          ]\n        }\n      }\n    }\n    else {\n      failwith ("A raffle is already open.")\n    }\n  }\n} with ((nil : list (operation)), store)\n')),(0,i.kt)("p",null,"Finally, we add this function to the main control flow :"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"function main (const action : raffleEntrypoints; const store : storage): returnType is\n  case action of [\n    OpenRaffle (param) -> open_raffle (param.0, param.1, param.2, store)\n  ]\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Keep in mind:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"check entrypoint inputs as much as possible"),(0,i.kt)("li",{parentName:"ul"},"the storage can be updated in an entrypoint"))))}u.isMDXComponent=!0}}]);