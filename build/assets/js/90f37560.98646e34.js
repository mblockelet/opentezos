"use strict";(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[4690],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=c(n),d=r,f=m["".concat(s,".").concat(d)]||m[d]||p[d]||o;return n?a.createElement(f,i(i({ref:t},u),{},{components:n})):a.createElement(f,i({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2912:function(e,t,n){n.d(t,{Z:function(){return o}});var a=n(7294),r="root_2W3B",o=function(e){var t=e.children;return a.createElement("div",{className:r},t)}},9604:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return y},default:function(){return x},frontMatter:function(){return b},metadata:function(){return k},toc:function(){return w}});var a=n(7462),r=n(3366),o=n(7294),i=n(3905),l=n(2389),s=n(9443);var c=function(){var e=(0,o.useContext)(s.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},u=n(3616),p=n(6010),m="tabItem_1uMI";function d(e){var t,n,a,r=e.lazy,i=e.block,l=e.defaultValue,s=e.values,d=e.groupId,f=e.className,g=o.Children.map(e.children,(function(e){if((0,o.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),h=null!=s?s:g.map((function(e){var t=e.props;return{value:t.value,label:t.label}})),v=(0,u.lx)(h,(function(e,t){return e.value===t.value}));if(v.length>0)throw new Error('Docusaurus error: Duplicate values "'+v.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var b=null===l?l:null!=(t=null!=l?l:null==(n=g.find((function(e){return e.props.default})))?void 0:n.props.value)?t:null==(a=g[0])?void 0:a.props.value;if(null!==b&&!h.some((function(e){return e.value===b})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+b+'" but none of its children has the corresponding value. Available values are: '+h.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var y=c(),k=y.tabGroupChoices,w=y.setTabGroupChoices,N=(0,o.useState)(b),x=N[0],T=N[1],O=[],I=(0,u.o5)().blockElementScrollPositionUntilNextRender;if(null!=d){var E=k[d];null!=E&&E!==x&&h.some((function(e){return e.value===E}))&&T(E)}var j=function(e){var t=e.currentTarget,n=O.indexOf(t),a=h[n].value;a!==x&&(I(t),T(a),null!=d&&w(d,a))},L=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a=O.indexOf(e.currentTarget)+1;n=O[a]||O[0];break;case"ArrowLeft":var r=O.indexOf(e.currentTarget)-1;n=O[r]||O[O.length-1]}null==(t=n)||t.focus()};return o.createElement("div",{className:"tabs-container"},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,p.Z)("tabs",{"tabs--block":i},f)},h.map((function(e){var t=e.value,n=e.label;return o.createElement("li",{role:"tab",tabIndex:x===t?0:-1,"aria-selected":x===t,className:(0,p.Z)("tabs__item",m,{"tabs__item--active":x===t}),key:t,ref:function(e){return O.push(e)},onKeyDown:L,onFocus:j,onClick:j},null!=n?n:t)}))),r?(0,o.cloneElement)(g.filter((function(e){return e.props.value===x}))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},g.map((function(e,t){return(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==x})}))))}function f(e){var t=(0,l.Z)();return o.createElement(d,(0,a.Z)({key:String(t)},e))}var g=function(e){var t=e.children,n=e.hidden,a=e.className;return o.createElement("div",{role:"tabpanel",hidden:n,className:a},t)},h=n(2912),v=["components"],b={id:"introduction",title:"Introduction",slug:"/ligo",authors:"Maxime Sallerin, Benjamin Pilia and Frank Hillard"},y=void 0,k={unversionedId:"ligo/introduction",id:"ligo/introduction",title:"Introduction",description:"Tezos smart contracts are written in Michelson, which is a stack-based language and the lowest level of language for a Tezos smart contract. Michelson code can be deployed as-is on the Tezos network.",source:"@site/docs/ligo/introduction.md",sourceDirName:"ligo",slug:"/ligo",permalink:"/ligo",editUrl:"https://gitlab.com/tezos-paris-hub/opentezos/-/blob/main/docs/ligo/introduction.md",tags:[],version:"current",lastUpdatedBy:"Damien ZONDA",lastUpdatedAt:1646498958,formattedLastUpdatedAt:"3/5/2022",frontMatter:{id:"introduction",title:"Introduction",slug:"/ligo",authors:"Maxime Sallerin, Benjamin Pilia and Frank Hillard"},sidebar:"docs",previous:{title:"Exam",permalink:"/smartpy/exam"},next:{title:"Installation",permalink:"/ligo/installation"}},w=[{value:"What&#39;s next",id:"whats-next",children:[],level:2}],N={toc:w};function x(e){var t=e.components,o=(0,r.Z)(e,v);return(0,i.kt)("wrapper",(0,a.Z)({},N,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Tezos smart contracts are written in ",(0,i.kt)("a",{parentName:"p",href:"https://opentezos.com/michelson"},"Michelson"),", which is a stack-based language and the lowest level of language for a Tezos smart contract. Michelson code can be deployed as-is on the Tezos network."),(0,i.kt)("p",null,"However, if reading or writing Michelson code is still easy for small smart contracts, it can become tedious for more complex smart contracts, as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"there are no variables and functions are not easy to use"),(0,i.kt)("li",{parentName:"ul"},"there is some syntactic sugar to combine multiple instructions but stack manipulation remains painful"),(0,i.kt)("li",{parentName:"ul"},"Michelson code cannot be broken down into several files"),(0,i.kt)("li",{parentName:"ul"},"stack-based languages are not commonly used when it comes to web development")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"LIGO offers an alternative.")),(0,i.kt)("p",null,"It is a high-level language for smart contract development.\nSmart contracts can be written in LIGO, then compiled into a single Michelson code file.\nThis Michelson file becomes the smart contract that will be deployed on a Tezos network."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(6241).Z})),(0,i.kt)("small",{className:"figure"},"FIGURE 1: Contextualization of LIGO in the Tezos ecosystem"),(0,i.kt)("p",null,"LIGO currently offers four ",(0,i.kt)("em",{parentName:"p"},"flavours")," of syntaxes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"PascaLigo"),", a syntax inspired by the Pascal language, provides an imperative developer experience.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"CameLigo"),", a syntax inspired from ",(0,i.kt)("a",{parentName:"p",href:"https://ocaml.org/"},"OCaml"),", that allows to write in a functional style.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"ReasonLigo"),", a syntax inspired from ",(0,i.kt)("a",{parentName:"p",href:"https://reasonml.github.io/"},"ReasonML"),", that builds on the strong points of OCaml but still aims to be familiar JavaScript developers.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"JsLigo"),", the latest syntax released, inspired by the popular JavaScript language."))),(0,i.kt)(h.Z,{mdxType:"NotificationBar"},(0,i.kt)("p",null,(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Imperative programming")," is a programming paradigm that describes the operations in sequences of instructions executed by the computer to change the program's state."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Functional programming")," is a declarative programming paradigm that considers computation as an evaluation of mathematical functions."))),(0,i.kt)("p",null,"Here is an example of a ",(0,i.kt)("em",{parentName:"p"},"Counter")," contract that handles a single integer ",(0,i.kt)("inlineCode",{parentName:"p"},"counter")," value in storage and allows users to increment, decrement or reset this counter."),(0,i.kt)(f,{defaultValue:"pascaligo",values:[{label:"PascaLigo",value:"pascaligo"},{label:"CameLigo",value:"cameligo"},{label:"ReasonLigo",value:"reasonligo"},{label:"JsLigo",value:"jsligo"}],mdxType:"Tabs"},(0,i.kt)(g,{value:"pascaligo",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"type storage is int\n\ntype parameter is\n| Increment of int\n| Decrement of int\n| Reset\n\ntype return is list (operation) * storage\n\nfunction main (const action : parameter; const store : storage) : return is\n  ((nil : list (operation)),\n  case action of [\n  | Increment (n) -> store + n\n  | Decrement (n) -> store - n\n  | Reset         -> 0\n  ])\n"))),(0,i.kt)(g,{value:"cameligo",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"type storage = int\n\ntype parameter =\n| Increment of int\n| Decrement of int\n| Reset\n\ntype return = operation list * storage\n\nlet main (action, store : parameter * storage) : return =\n  ([] : operation list),\n  (match action with\n  | Increment n -> store + n\n  | Decrement n -> store - n\n  | Reset       -> 0)\n"))),(0,i.kt)(g,{value:"reasonligo",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"type storage = int;\n\ntype parameter =\n| Increment (int)\n| Decrement (int)\n| Reset;\n\ntype return = (list (operation), storage);\n\nlet main = ((action, store): (parameter, storage)) : return => {\n  (([] : list (operation)),\n  (switch (action) {\n  | Increment (n) => store + n\n  | Decrement (n) => store - n\n  | Reset         => 0}));\n};\n"))),(0,i.kt)(g,{value:"jsligo",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'type storage = int;\n\ntype parameter =\n| ["Increment", int]\n| ["Decrement", int]\n| ["Reset"];\n\ntype return_ = [list<operation>, storage];\n\nlet main = ([action, store]: [parameter, storage]) : return_ => {\n  return [\n    list([]) as list<operation>,\n    match(action, {\n      Increment: (n: int) => store + n,\n      Decrement: (n: int) => store - n,\n      Reset:     ()       => 0\n    })\n  ];\n};\n')))),(0,i.kt)("h2",{id:"whats-next"},"What's next"),(0,i.kt)("p",null,"In the following chapter, we will develop smart contracts in LIGO, compile them and deploy them."),(0,i.kt)("p",null,"We chose to write this module in PascaLigo. The main difference between the syntaxes is that PascaLigo is more imperative while ReasonLigo and CameLigo are more functional. "),(0,i.kt)("p",null,"This module aims to teach developers the basics of LIGO by providing them with the essential skills to write and deploy their first smart contract onto the Tezos network. It will include the basics of the LIGO language, inspired from the ",(0,i.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/language-basics/types"},"official LIGO documentation"),", as well as detailed smart contract examples and a final exam to check your understanding."))}x.isMDXComponent=!0},6241:function(e,t,n){t.Z=n.p+"assets/images/intro_schema-93d62e83c79e9504eec5950fc06cf889.svg"}}]);