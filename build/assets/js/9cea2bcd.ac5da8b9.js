"use strict";(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[7131],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=s(n),d=o,h=u["".concat(p,".").concat(d)]||u[d]||m[d]||r;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9660:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return c},default:function(){return u}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),i=["components"],l={id:"deploy-a-contract",title:"Compiling and deploying",authors:"Maxime Sallerin and Benjamin Pilia"},p=void 0,s={unversionedId:"ligo/deploy-a-contract",id:"ligo/deploy-a-contract",title:"Compiling and deploying",description:"Compiling a contract",source:"@site/docs/ligo/deploy-a-contract.md",sourceDirName:"ligo",slug:"/ligo/deploy-a-contract",permalink:"/opentezos/ligo/deploy-a-contract",editUrl:"https://gitlab.com/tezos-paris-hub/opentezos/-/blob/main/docs/ligo/deploy-a-contract.md",tags:[],version:"current",lastUpdatedBy:"Damien ZONDA",lastUpdatedAt:1646498958,formattedLastUpdatedAt:"3/5/2022",frontMatter:{id:"deploy-a-contract",title:"Compiling and deploying",authors:"Maxime Sallerin and Benjamin Pilia"},sidebar:"docs",previous:{title:"Refactoring",permalink:"/opentezos/ligo/write-contract-ligo/5-refactoring"},next:{title:"Unit Testing with PyTezos",permalink:"/opentezos/ligo/unit-testing"}},c=[{value:"Compiling a contract",id:"compiling-a-contract",children:[],level:2},{value:"Simulating (Dry-running) a contract",id:"simulating-dry-running-a-contract",children:[],level:2},{value:"Defining the initial storage",id:"defining-the-initial-storage",children:[],level:2},{value:"Invoking the contract with a parameter",id:"invoking-the-contract-with-a-parameter",children:[],level:2},{value:"Deploy",id:"deploy",children:[],level:2},{value:"Invoke",id:"invoke",children:[],level:2},{value:"Example",id:"example",children:[{value:"Compile",id:"compile",children:[],level:3},{value:"Initial storage",id:"initial-storage",children:[],level:3},{value:"Invocation parameter",id:"invocation-parameter",children:[],level:3},{value:"Simulating",id:"simulating",children:[],level:3},{value:"Deploy",id:"deploy-1",children:[],level:3},{value:"Invoke",id:"invoke-1",children:[],level:3},{value:"Accessing storage",id:"accessing-storage",children:[],level:3}],level:2},{value:"Some specificities for Maps, Tuples and Records",id:"some-specificities-for-maps-tuples-and-records",children:[{value:"Maps",id:"maps",children:[],level:3},{value:"Tuples",id:"tuples",children:[],level:3},{value:"Records",id:"records",children:[],level:3}],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],m={toc:c};function u(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"compiling-a-contract"},"Compiling a contract"),(0,r.kt)("p",null,"In order to deploy a contract in a Tezos network, we first need to compile it. This is done using a compiler (aka LIGO compiler) that transforms LIGO code into Michelson code."),(0,r.kt)("p",null,"Michelson smart contracts are stored in a file with the ",(0,r.kt)("inlineCode",{parentName:"p"},".tz")," extension."),(0,r.kt)("p",null,"Here is how to transform a LIGO code into a Michelson code using the LIGO compiler in the command line."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile contract SOURCE_LIGO_FILE\n")),(0,r.kt)("p",null,"Where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"SOURCE_LIGO_FILE")," is the path to your LIGO file containing the main function.")),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile contract examples/counter.ligo\n")),(0,r.kt)("p",null,"The examples are detailed later in the chapter, see ",(0,r.kt)("a",{parentName:"p",href:"#example"},"here"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"You can store the Michelson output of the command above in .tz file in order to use it later when deploying the contract:"),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre"},"ligo compile contract SOURCE_LIGO_FILE > MICHELSON_FILE\n"))),(0,r.kt)("h2",{id:"simulating-dry-running-a-contract"},"Simulating (Dry-running) a contract"),(0,r.kt)("p",null,"Testing a contract would be pretty tricky if you always had to set up a live node to run tests. Fortunately, an easy alternative is to use LIGO's built-in dry-run feature. Dry-running is a simulated execution of the smart contract as if it was deployed on a real chain. It works by simulating the main execution-function, based on a mock storage value and a parameter."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run dry-run [flags] SOURCE_LIGO_FILE 'ACTION(P)' 'STORAGE_STATE'\n")),(0,r.kt)("p",null,"where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"ACTION(P)")," is a LIGO expression used to specify the action that triggers the associated entrypoint with the corresponding parameter p."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"STORAGE_STATE")," is the state of the storage when simulating the execution of the entrypoint.")),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run dry-run counter.ligo 'Increment(5)' 3\n// Outputs: ( LIST_EMPTY() , 8 )\n")),(0,r.kt)("h2",{id:"defining-the-initial-storage"},"Defining the initial storage"),(0,r.kt)("p",null,"The Michelson output of the following command can be used to init the storage when deploying the contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile storage SOURCE_LIGO_FILE 'STORAGE_STATE'\n")),(0,r.kt)("p",null,"where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"STORAGE_STATE")," is a LIGO expression that defines the initial state of the storage.")),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile storage counter.ligo 5\n// Outputs: 5\n")),(0,r.kt)("h2",{id:"invoking-the-contract-with-a-parameter"},"Invoking the contract with a parameter"),(0,r.kt)("p",null,"The Michelson output of the following command can be used as the entrypoint name when invoking an entrypoint of the smart contract (as well as the parameters of that entrypoint)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile-parameter SOURCE_LIGO_FILE MAIN_FUNCTION 'ACTION(P)'\n")),(0,r.kt)("p",null,"where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"ACTION(P)")," is a LIGO expression used to specify the action that triggers the associated entrypoint with the corresponding parameter p.")),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile parameter examples/counter.ligo main 'Increment(5)'\n// Outputs: (Right 5)\n")),(0,r.kt)("h1",{id:"deploy-and-invoke"},"Deploy and Invoke"),(0,r.kt)("h2",{id:"deploy"},"Deploy"),(0,r.kt)("p",null,"A smart contract must be deployed on the blockchain in order to be invoked. When deploying a smart contract on the blockchain, one must specify the initial state of the storage."),(0,r.kt)("p",null,'The deployment of a smart contract in Tezos is called "',(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"origination")),'".'),(0,r.kt)("p",null,"Here is the syntax for the Tezos command line to deploy a smart contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client originate contract CONTRACT_NAME transferring AMOUNT_TEZ from FROM_USER \\\n             running MICHELSON_FILE \\\n             --init 'INITIAL_STORAGE' --burn-cap GAZ_FEE\n")),(0,r.kt)("p",null,"where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"CONTRACT_NAME")," is the name given to the contract."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"MICHELSON_FILE")," is the path for the Michelson smart contract code (.tz file)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"AMOUNT_TEZ")," is the quantity of Tez being transferred to the newly deployed contract. If a contract balance reaches 0 then it is deactivated."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"FROM_USER")," account from which the Tez are taken (and transferred to the new contract)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"INITIAL_STORAGE")," is a Michelson expression. The ",(0,r.kt)("inlineCode",{parentName:"li"},"--init")," parameter is used to specify the initial state of the storage."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"GAZ_FEE")," is a specified maximal fee the user is willing to pay for this operation (using the ",(0,r.kt)("inlineCode",{parentName:"li"},"--burn-cap")," parameter).")),(0,r.kt)("h2",{id:"invoke"},"Invoke"),(0,r.kt)("p",null,"Once the smart contract has been deployed on the blockchain (contract-origination operation baked into a block), it is possible to invoke an entrypoint from the smart contract using the command line. Here is the syntax of the Tezos command line to invoke a smart contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client transfer AMOUNT_TEZ from USER to CONTRACT_NAME --arg 'ENTRYPOINT_INVOCATION' --dry-run\n")),(0,r.kt)("p",null,"where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"AMOUNT_TEZ")," is the quantity of Tez being transferred to the contract."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"CONTRACT_NAME")," is the name given to the contract."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"ENTRYPOINT_INVOCATION")," is a Michelson expression of the entrypoint and the corresponding parameter. The ",(0,r.kt)("inlineCode",{parentName:"li"},"--arg")," parameter specifies an entrypoint call.")),(0,r.kt)("p",null,"\u26a0\ufe0f Notice that the ",(0,r.kt)("inlineCode",{parentName:"p"},"--dry-run")," parameter simulates the invocation of the entrypoint."),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,"Let's consider a counter contract for our example."),(0,r.kt)("p",null,"Our counter contract will store a single ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," as its storage,\nand will accept an ",(0,r.kt)("inlineCode",{parentName:"p"},"action")," variant in order to re-route our single ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," function to two entrypoints for ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," (addition) and ",(0,r.kt)("inlineCode",{parentName:"p"},"sub")," (subtraction)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"type parameter is\n  Increment of int\n| Decrement of int\n\ntype storage is int\n\ntype return is list (operation) * storage\n\nfunction add (const n : int; const store : storage) : storage is store + n\nfunction sub (const n : int; const store : storage) : storage is store - n\n\nfunction main (const action : parameter; const store : storage) : return is\n  ((nil : list(operation)),\n  case action of [\n    | Increment (n) -> add (n, store)\n    | Decrement (n) -> sub (n, store)\n  ])\n")),(0,r.kt)("h3",{id:"compile"},"Compile"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile contract counter.ligo > counter.tz\n")),(0,r.kt)("p",null,"The command above outputs the following Michelson code:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that the output has been saved in the Michelson file ",(0,r.kt)("inlineCode",{parentName:"p"},"counter.tz"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"{ parameter (or (int %decrement) (int %increment)) ;\n  storage int ;\n  code { UNPAIR ; IF_LEFT { SWAP ; SUB } { ADD } ; NIL operation ; PAIR } }\n")),(0,r.kt)("h3",{id:"initial-storage"},"Initial storage"),(0,r.kt)("p",null,"However, in order to ",(0,r.kt)("strong",{parentName:"p"},"originate")," a Michelson contract on Tezos, we also need to provide its initial storage value, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"compile storage")," to compile the LIGO representation of the storage to Michelson."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile storage counter.ligo 5\n// Outputs: 5\n")),(0,r.kt)("h3",{id:"invocation-parameter"},"Invocation parameter"),(0,r.kt)("p",null,"The same rules apply for the parameters. We will need to use ",(0,r.kt)("inlineCode",{parentName:"p"},"compile parameter")," to compile our action variant into Michelson, here's how:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile parameter counter.ligo 'Increment(5)'\n// Outputs: (Right 5)\n")),(0,r.kt)("p",null,"We can now use ",(0,r.kt)("inlineCode",{parentName:"p"},"(Right 5)"),", which is a Michelson value, to invoke our contract via ",(0,r.kt)("inlineCode",{parentName:"p"},"tezos-client"),"."),(0,r.kt)("h3",{id:"simulating"},"Simulating"),(0,r.kt)("p",null,"To dry-run the counter-contract, we provide a ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," function with a variant ",(0,r.kt)("em",{parentName:"p"},"parameter")," of value ",(0,r.kt)("inlineCode",{parentName:"p"},"Increment (5)")," and an initial storage value of ",(0,r.kt)("inlineCode",{parentName:"p"},"3"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run dry-run counter.ligo 'Increment(5)' 3\n// Outputs: ( LIST_EMPTY() , 8 )\n")),(0,r.kt)("p",null,"The simulation shows that our storage would have been incremented to 8."),(0,r.kt)("h3",{id:"deploy-1"},"Deploy"),(0,r.kt)("p",null,"Now that we have verified that our code compiles well and that it was functional, we can deploy our contract on the blockchain."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client originate contract counterContract for boostrap1 transferring 1 from boostrap2 \\\n             running code.tz \\\n             --init '0' --burn-cap 0.12525\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that you can simulate the deployment by adding the ",(0,r.kt)("inlineCode",{parentName:"p"},"--dry-run")," parameter to the above command. ",(0,r.kt)("em",{parentName:"p"},"boostrap1")," and ",(0,r.kt)("em",{parentName:"p"},"boostrap2")," are users from the Tezos sandbox. Sandboxed mode is a way to run a 'localhost-only' instance of a Tezos network. Find out more about the sandboxed mode ",(0,r.kt)("a",{parentName:"p",href:"examples#sandboxed-mode"},"here"),".")),(0,r.kt)("h3",{id:"invoke-1"},"Invoke"),(0,r.kt)("p",null,"Let's invoke the entrypoint ",(0,r.kt)("inlineCode",{parentName:"p"},"Increment(5)")," of the smart contract. Remember that the output of the ",(0,r.kt)("inlineCode",{parentName:"p"},"compile parameter")," of this entrypoint was ",(0,r.kt)("inlineCode",{parentName:"p"},"(Right 5)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client transfer 5 from boostrap1 to counterContract --arg '(Right 5)'\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that you can simulate the invocation by adding the ",(0,r.kt)("inlineCode",{parentName:"p"},"--dry-run")," parameter to the above command.")),(0,r.kt)("h3",{id:"accessing-storage"},"Accessing storage"),(0,r.kt)("p",null,"You can access the stored value with the following command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"tezos-client get contract storage for counterContract\n")),(0,r.kt)("h2",{id:"some-specificities-for-maps-tuples-and-records"},"Some specificities for Maps, Tuples and Records"),(0,r.kt)("p",null,"Consider the following LIGO code snippet for the storage definition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"//starmap.ligo\ntype coordinates is ( int * int * int)\ntype storage is map (string, coordinates)\n\nfunction main (const _action : unit; const store : storage) : list(operation) * storage is\n  ((nil : list(operation)), store)\n")),(0,r.kt)("h3",{id:"maps"},"Maps"),(0,r.kt)("p",null,"The initialization of the elements of a map is specified between ",(0,r.kt)("inlineCode",{parentName:"p"},"map [")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"]")," and elements are separated by a semi-colon ",(0,r.kt)("inlineCode",{parentName:"p"},";"),". Each element is a key/value pair separated by ",(0,r.kt)("inlineCode",{parentName:"p"},"->"),"."),(0,r.kt)("p",null,"Initialization of the elements of a map follows the syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"map[ KEY1 -> VALUE1; KEY2 -> VALUE2 ]\n")),(0,r.kt)("p",null,"Here is an example of a command-line ",(0,r.kt)("inlineCode",{parentName:"p"},"ligo compile storage")," for transpiling a map."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile storage starmap.ligo \'map [ "earth" -> (2,7,1); "sun" -> (0,0,0) ]\'\n')),(0,r.kt)("p",null,"This command returns:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'{ Elt "earth" (Pair (Pair 2 7) 1) ; Elt "sun" (Pair (Pair 0 0) 0) }\n')),(0,r.kt)("h3",{id:"tuples"},"Tuples"),(0,r.kt)("p",null,"Initialization of the tuple elements is specified between ",(0,r.kt)("inlineCode",{parentName:"p"},"(")," and ",(0,r.kt)("inlineCode",{parentName:"p"},")"),", and separated by comma ",(0,r.kt)("inlineCode",{parentName:"p"},","),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"(VALUE1, VALUE2, VALUE3)\n")),(0,r.kt)("p",null,"Here is an example of a command-line ",(0,r.kt)("inlineCode",{parentName:"p"},"ligo compile storage")," for compiling a map containing a tuple."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile storage starmap.ligo 'map [ \"earth\" -> (2,7,1) ]'\n")),(0,r.kt)("p",null,"This command returns:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'{ Elt "earth" (Pair (Pair 2 7) 1) }\n')),(0,r.kt)("p",null,"When specifying an empty map, one must set the map [] into the expected type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile storage starmap.ligo '(map []: map(string,coordinates))'\n")),(0,r.kt)("h3",{id:"records"},"Records"),(0,r.kt)("p",null,"Initialization of elements in a record is specified between map ",(0,r.kt)("inlineCode",{parentName:"p"},"[")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"]")," and elements separated by a semi-colon ",(0,r.kt)("inlineCode",{parentName:"p"},";"),".",(0,r.kt)("br",{parentName:"p"}),"\n","Each element is a key/value pair separated by ",(0,r.kt)("inlineCode",{parentName:"p"},"=")," and follows the syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"record[ KEY1 = VALUE1; KEY2 = VALUE2 ]\n")),(0,r.kt)("p",null,"We should now have a record instead of a tuple for ",(0,r.kt)("inlineCode",{parentName:"p"},"coordinates"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"//starmap2.ligo\ntype coordinates is record [\n  x : int;\n  y : int;\n  z : int\n]\ntype storage is map (string, coordinates)\n\nfunction main (const _action : unit; const store : storage) : list(operation) * storage is\n  ((nil : list(operation)), store)\n")),(0,r.kt)("p",null,"We can compile the storage as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile storage starmap2.ligo 'map [ \"earth\" -> record [x=2;y=7;z=1] ]'\n")),(0,r.kt)("p",null,"This command returns:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'{ Elt "earth" (Pair (Pair 2 7) 1) }\n')),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"In this section, we have seen how to use the LIGO compiler command lines to interact with a smart contract. We have seen how to compile a LIGO code in Michelson code, then simulate the behavior of its smart contract and, finally, the deployment and the invocation of entrypoints."))}u.isMDXComponent=!0}}]);