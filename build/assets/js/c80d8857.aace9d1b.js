"use strict";(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[3365],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return f}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),f=a,m=u["".concat(l,".").concat(f)]||u[f]||d[f]||r;return n?o.createElement(m,i(i({ref:t},p),{},{components:n})):o.createElement(m,i({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2912:function(e,t,n){n.d(t,{Z:function(){return r}});var o=n(7294),a="root_2W3B",r=function(e){var t=e.children;return o.createElement("div",{className:a},t)}},3003:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return u}});var o=n(7462),a=n(3366),r=(n(7294),n(3905)),i=(n(2912),["components"]),s={id:"4-close-raffle",title:"Close raffle",authors:"Maxime Sallerin and Benjamin Pilia"},l=void 0,c={unversionedId:"ligo/write-contract-ligo/4-close-raffle",id:"ligo/write-contract-ligo/4-close-raffle",title:"Close raffle",description:"Smart Contract development: Close raffle entrypoint",source:"@site/docs/ligo/write-contract-ligo/4-close-raffle.md",sourceDirName:"ligo/write-contract-ligo",slug:"/ligo/write-contract-ligo/4-close-raffle",permalink:"/ligo/write-contract-ligo/4-close-raffle",editUrl:"https://gitlab.com/tezos-paris-hub/opentezos/-/blob/main/docs/ligo/write-contract-ligo/4-close-raffle.md",tags:[],version:"current",lastUpdatedBy:"Damien ZONDA",lastUpdatedAt:1646498958,formattedLastUpdatedAt:"3/5/2022",sidebarPosition:4,frontMatter:{id:"4-close-raffle",title:"Close raffle",authors:"Maxime Sallerin and Benjamin Pilia"},sidebar:"docs",previous:{title:"Buy ticket",permalink:"/ligo/write-contract-ligo/3-buy-ticket"},next:{title:"Refactoring",permalink:"/ligo/write-contract-ligo/5-refactoring"}},p=[{value:"Smart Contract development: Close raffle entrypoint",id:"smart-contract-development-close-raffle-entrypoint",children:[{value:"Optional values",id:"optional-values",children:[],level:3},{value:"Transactions",id:"transactions",children:[],level:3},{value:"About randomness in smart contracts",id:"about-randomness-in-smart-contracts",children:[],level:3},{value:"Adding the CloseRaffle entrypoint",id:"adding-the-closeraffle-entrypoint",children:[],level:3},{value:"Implementing the CloseRaffle logic",id:"implementing-the-closeraffle-logic",children:[],level:3}],level:2}],d={toc:p};function u(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"smart-contract-development-close-raffle-entrypoint"},"Smart Contract development: Close raffle entrypoint"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"LIGO concepts used in this part: with this last entrypoint, you will learn how to use transactions to send the reward to the winner. In addition, this will be the opportunity to warn you about some limitations of the language.")),(0,r.kt)("p",null,"The last step is to close the raffle, pick a winner and send the reward. This last entrypoint will show how to send a transaction from the contract and some collections manipulations"),(0,r.kt)("p",null,"Five steps are required:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Check that the calling address is the administrator"),(0,r.kt)("li",{parentName:"ol"},"Check that the closing date has been reached and that the raffle is still open"),(0,r.kt)("li",{parentName:"ol"},"Pick a winner"),(0,r.kt)("li",{parentName:"ol"},"Send the reward to the winner"),(0,r.kt)("li",{parentName:"ol"},"Reset the storage")),(0,r.kt)("p",null,"New variables won't be stored as the storage is not expected to be modified. However, the third step raises a problem: how should the winner be picked? There are 3 possibilities:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The administrator chooses the winner when calling the entrypoint. Participants are likely not to buy a ticket if the administrator can choose the winner himself."),(0,r.kt)("li",{parentName:"ol"},"The winner is randomly chosen when calling this entrypoint."),(0,r.kt)("li",{parentName:"ol"},"The winner is chosen at the beginning by the administrator, but this is only revealed at the end of the raffle.")),(0,r.kt)("h3",{id:"optional-values"},"Optional values"),(0,r.kt)("p",null,"The option type is a predefined variant type that is used to express whether there is a value of some type or none. This is especially useful when calling a partial function, that is, a function that is not defined for some inputs. In that case, the value of the option type would be None, otherwise Some (v), where v is some meaningful value of any type. An example in arithmetic is the division operation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function div (const a : nat; const b : nat) : option (nat) is\n  if b = 0n then None else Some(a/b)\n")),(0,r.kt)("h3",{id:"transactions"},"Transactions"),(0,r.kt)("p",null,"You can transfer Tez to an account, and invoke a function from another smart contract. For this, use:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"Tezos.transaction (<parameter>, <mutez>, <contract>);\n")),(0,r.kt)("p",null,"where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"parameter")," is the entrypoint of another contract, or use ",(0,r.kt)("inlineCode",{parentName:"li"},"unit")," if you are transferring to a wallet address,"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"mutez")," is the amount to transfer,"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"contract")," is the contract interface of the targeted contract. It can be retrieved with the ",(0,r.kt)("inlineCode",{parentName:"li"},"Tezos.get_contract_opt")," built-in function from the address of the other contract or the wallet.")),(0,r.kt)("p",null,"Here's an example of retrieving the contract interface from the ",(0,r.kt)("em",{parentName:"p"},"winner")," ",(0,r.kt)("inlineCode",{parentName:"p"},"address"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const receiver : contract (unit) = \n  case (Tezos.get_contract_opt (winner) : option (contract (unit))) of [\n  | Some (c) -> c\n  | None -> (failwith ("winner contract not found.") : contract (unit))\n  ]\n\nconst op : operation = Tezos.transaction(unit, store.jackpot, receiver);\n')),(0,r.kt)("p",null,"Notice that the ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_opt")," built-in function call will return an ",(0,r.kt)("inlineCode",{parentName:"p"},"option (contract (unit))"),", thus allowing us to verify that the ",(0,r.kt)("em",{parentName:"p"},"winner")," address is valid."),(0,r.kt)("h3",{id:"about-randomness-in-smart-contracts"},"About randomness in smart contracts"),(0,r.kt)("p",null,"The second option is not easily implemented in smart contracts. In any classical programming language (",(0,r.kt)("em",{parentName:"p"},"Python"),", ",(0,r.kt)("em",{parentName:"p"},"C"),", ",(0,r.kt)("em",{parentName:"p"},"Java"),", ...), a ",(0,r.kt)("strong",{parentName:"p"},"random")," function is directly usable from the standard API. With smart contracts, it is not possible."),(0,r.kt)("p",null,"Indeed, each smart contract execution has to be verified by any node in the network. However, how could this execution be verified if there is a random variable (one that would change for every node)?"),(0,r.kt)("p",null,"It might seem to be a good idea to use blockchain events (transaction hash, block timestamp, ...) as a source of randomness. However, in the end, bakers that create blocks could use this to their advantage."),(0,r.kt)("p",null,"The only solution is to be the use of an external source of randomness or a secure cryptographic scheme. This can be achieved using ",(0,r.kt)("em",{parentName:"p"},"Oracles")," but this topic goes well beyond the level of this course."),(0,r.kt)("p",null,"For educational purposes, we will at first hardcode a ticket id winner. Then, the smart contract will be refactored, using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Bytes")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Crypto")," modules."),(0,r.kt)("h3",{id:"adding-the-closeraffle-entrypoint"},"Adding the CloseRaffle entrypoint"),(0,r.kt)("p",null,"The smart contract needs to expose this last entrypoint. The method is the same that has been detailed for the first and second entrypoint:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Defining the type parameter. The type should be ",(0,r.kt)("inlineCode",{parentName:"li"},"unit"),", since the administrator needs to close the raffle without any other piece of information:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"type closeRaffleParameter is unit\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Adding the entrypoint in the variant:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"type raffleEntrypoints is\n| OpenRaffle of openRaffleParameter\n| BuyTicket of buyTicketParameter\n| CloseRaffle of closeRaffleParameter\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Handling the new entrypoint in the control flow:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function main (const action : raffleEntrypoints; const store : storage): returnType is\n  case action of [\n    | OpenRaffle (param) -> open_raffle (param.0, param.1, param.2, store)\n    | BuyTicket (param) -> buy_ticket(param, store)\n    | CloseRaffle (param) -> close_raffle (param, store)\n  ]\n")),(0,r.kt)("h3",{id:"implementing-the-closeraffle-logic"},"Implementing the CloseRaffle logic"),(0,r.kt)("p",null,"Let's create an empty function for this entrypoint:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"  function close_raffle (const param: unit; const store : storage) : returnType is\n    block { const operations : list(operation) = nil; } with (operations, store)\n")),(0,r.kt)("p",null,"There is a slight difference with this entrypoint function: it has to return an operation. As a result, the list of operations won't be empty and will be filled with one operation from within the function block."),(0,r.kt)("p",null,"The usual checks have to be implemented:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"only the administrator can close the raffle,"),(0,r.kt)("li",{parentName:"ol"},"the closing date must have been reached,"),(0,r.kt)("li",{parentName:"ol"},"the raffle must be open")),(0,r.kt)("p",null,"The winner will be picked using an hardcoded value. However, even if there are only two participants, the raffle must have a winner. So, the number of participants must be known so that the winning id matches an id ticket. For this, a modulo will be used: ",(0,r.kt)("inlineCode",{parentName:"p"},"hardcoded_number mod number_of_participants"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'function close_raffle (const _param : unit; const store : storage) : returnType is\n  block {\n    const operations : list(operation) = nil;\n    if Tezos.source =/= store.admin then failwith("Administrator not recognized.")\n    else {\n      if store.raffle_is_open then {\n        if Tezos.now < store.close_date then failwith("The raffle must remain open for at least 7 days.")\n        else{\n          const number_of_players : nat = Set.size(store.players);\n          const random_number : nat = 467n; // hardcoded number\n          const winning_ticket_id : nat = random_number mod number_of_players; // modulo expression\n        }\n      } else {\n        failwith("The raffle is closed.")\n      }\n    }\n  } with (operations, store)\n')),(0,r.kt)("p",null,"The winning ticket is now chosen. The next step is to find its owner from the ",(0,r.kt)("inlineCode",{parentName:"p"},"sold_tickets big_map"),". Since a key might not exist in a big map, fetching the value always return an option. This option is handled with pattern matching as show below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'function close_raffle (const _param: unit; const store : storage) : returnType is {\n  const operations : list(operation) = nil;\n  if Tezos.source =/= store.admin\n  then failwith("Administrator not recognized.")\n  else {\n    if store.raffle_is_open then {\n      if Tezos.now < store.close_date\n      then failwith("The raffle must remain open for at least 7 days.")\n      else{\n        const number_of_players : nat = Set.size(store.players);\n        const random_number : nat = 467n; // hardcoded number\n        const winning_ticket_id : nat = random_number mod number_of_players; // modulo expression\n\n        const winner : address =\n          case (store.sold_tickets[winning_ticket_id]) of [\n          | Some (a) -> a\n          | None -> (failwith ("Winner address not found") : address)\n          ];\n      }\n    } else {\n      failwith("The raffle is closed.")\n    }\n  }\n} with (operations, store)\n')),(0,r.kt)("p",null,"The winner has been found and now has to be rewarded. First, we need to check that this address does exist, then create a transaction which will be added to the operations list:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"const operations")," has been replaced by ",(0,r.kt)("inlineCode",{parentName:"p"},"var operations"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'function close_raffle (const _param: unit; const store : storage) : returnType is {\n  var operations : list(operation) := nil;\n  if Tezos.source =/= store.admin\n  then failwith("Administrator not recognized.")\n  else {\n    if store.raffle_is_open then {\n      if Tezos.now < store.close_date\n      then failwith("The raffle must remain open for at least 7 days.")\n      else{\n        const number_of_players : nat = Set.size(store.players);\n        const random_number : nat = 467n; // hardcoded number\n        const winning_ticket_id : nat = random_number mod number_of_players; // modulo expression\n\n        const winner : address =\n          case (store.sold_tickets[winning_ticket_id]) of [\n          | Some (a) -> a\n          | None -> (failwith ("Winner address not found") : address)\n          ];\n\n        const receiver : contract (unit) =\n          case (Tezos.get_contract_opt (winner) : option (contract (unit))) of [\n          | Some (c) -> c\n          | None -> (failwith ("Winner contract not found.") : contract (unit))\n          ];\n\n        const op : operation = Tezos.transaction(unit, store.jackpot, receiver);\n        operations := list [ op; ];\n      }\n    } else {\n      failwith("The raffle is closed.")\n    }\n  }\n} with (operations, store)\n')),(0,r.kt)("p",null,"The operations variable is no longer empty. This entrypoint does return a transaction that will be sent by the smart contract."),(0,r.kt)("p",null,"Finally, the storage need to be reset. All the fields will be filled with empty values:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"const store")," has been replaced by ",(0,r.kt)("inlineCode",{parentName:"p"},"var store"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'function close_raffle (const _param: unit; var store : storage) : returnType is {\n  const operations : list(operation) = nil;\n  if Tezos.source =/= store.admin\n  then failwith("Administrator not recognized.")\n  else {\n    if store.raffle_is_open then {\n      if Tezos.now < store.close_date\n      then failwith("The raffle must remain open for at least 7 days.")\n      else{\n        const number_of_players : nat = Set.size(store.players);\n        const random_number : nat = 467n; // hardcoded number\n        const winning_ticket_id : nat = random_number mod number_of_players; // modulo expression\n\n        const winner : address =\n          case (store.sold_tickets[winning_ticket_id]) of [\n          | Some (a) -> a\n          | None -> (failwith ("Winner address not found") : address)\n          ];\n\n        const receiver : contract (unit) =\n          case (Tezos.get_contract_opt (winner) : option (contract (unit))) of [\n          | Some (c) -> c\n          | None -> (failwith ("Winner contract not found.") : contract (unit))\n          ];\n\n        const op : operation = Tezos.transaction(unit, store.jackpot, receiver);\n        operations := list [ op; ];\n\n        patch store with record [\n          jackpot = 0tez;\n          close_date = (0 : timestamp);\n          description = ("raffle is currently closed" : string);\n          raffle_is_open = False;\n          players = (set[] : set(address));\n          sold_tickets = (big_map[] : big_map (nat, address));\n        ];\n      }\n    } else {\n      failwith("The raffle is closed.")\n    }\n  }\n} with (operations, store)\n')))}u.isMDXComponent=!0}}]);