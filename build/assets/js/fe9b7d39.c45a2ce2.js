"use strict";(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[1976],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return f}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(t),f=o,h=d["".concat(l,".").concat(f)]||d[f]||u[f]||r;return t?a.createElement(h,s(s({ref:n},p),{},{components:t})):a.createElement(h,s({ref:n},p))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,s=new Array(r);s[0]=d;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var c=2;c<r;c++)s[c]=t[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},287:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var a=t(7462),o=t(3366),r=(t(7294),t(3905)),s=["components"],i={id:"basics",disable_pagination:!0,title:"Frontend (Basics)",authors:"Benjamin Pilia"},l=void 0,c={unversionedId:"dapp/basics",id:"dapp/basics",title:"Frontend (Basics)",description:"So far, we have a deployed a contract and setup a wallet, we can now start to develop the frontend part of our Dapp. The frontend will interact with a deployed Raffle smart contract.",source:"@site/docs/dapp/front.md",sourceDirName:"dapp",slug:"/dapp/basics",permalink:"/dapp/basics",editUrl:"https://gitlab.com/tezos-paris-hub/opentezos/-/blob/main/docs/dapp/front.md",tags:[],version:"current",lastUpdatedBy:"Aymeric",lastUpdatedAt:1628209659,formattedLastUpdatedAt:"8/6/2021",frontMatter:{id:"basics",disable_pagination:!0,title:"Frontend (Basics)",authors:"Benjamin Pilia"},sidebar:"docs",previous:{title:"Temple Wallet",permalink:"/dapp/temple"},next:{title:"Frontend (Advanced)",permalink:"/dapp/front_user_experience"}},p=[{value:"Project initialisation",id:"project-initialisation",children:[],level:2},{value:"Temple Integration",id:"temple-integration",children:[{value:"Wallet connexion",id:"wallet-connexion",children:[],level:3},{value:"Wallet information",id:"wallet-information",children:[],level:3}],level:2},{value:"Displaying the storage",id:"displaying-the-storage",children:[{value:"Handling big maps",id:"handling-big-maps",children:[],level:3}],level:2},{value:"Launching a new raffle",id:"launching-a-new-raffle",children:[{value:"New raffle information",id:"new-raffle-information",children:[{value:"DatePicker installation",id:"datepicker-installation",children:[],level:4},{value:"Form creation",id:"form-creation",children:[],level:4}],level:3},{value:"New raffle button",id:"new-raffle-button",children:[{value:"web3 installation",id:"web3-installation",children:[],level:4},{value:"Implementation",id:"implementation",children:[],level:4}],level:3},{value:"End-to-end testing",id:"end-to-end-testing",children:[],level:3}],level:2},{value:"Buying tickets",id:"buying-tickets",children:[{value:"Implementation",id:"implementation-1",children:[],level:3},{value:"End-to-end testing",id:"end-to-end-testing-1",children:[],level:3}],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],u={toc:p};function d(e){var n=e.components,i=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},u,i,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"So far, we have a deployed a contract and setup a wallet, we can now start to develop the frontend part of our Dapp. The frontend will interact with a deployed ",(0,r.kt)("em",{parentName:"p"},"Raffle")," smart contract."),(0,r.kt)("p",null,"This chapter is not a tutorial about ",(0,r.kt)("em",{parentName:"p"},"React"),", nor how to build a nice UI, its purpose is to show the basic usage of the ",(0,r.kt)("em",{parentName:"p"},"Temple Wallet")," in a Dapp use case. Thus, it requires some knowledge about ",(0,r.kt)("a",{parentName:"p",href:"https://www.w3schools.com/css/"},"CSS"),", ",(0,r.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/getting-started.html"},"React")," and ",(0,r.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-intro.html"},"React Hooks"),"."),(0,r.kt)("p",null,"In this chapter, we will learn:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"How to setup a new project."),(0,r.kt)("li",{parentName:"ol"},"How to connect a React application to a Wallet."),(0,r.kt)("li",{parentName:"ol"},"How to fetch data from the blockchain (we will retrieve and present account balances and data from contract storage, including some big maps)."),(0,r.kt)("li",{parentName:"ol"},"How to interact with a smart contract (with contract calls through ",(0,r.kt)("em",{parentName:"li"},"Temple"),"). ")),(0,r.kt)("p",null,"In the end, our application will look like:"),(0,r.kt)("p",null,(0,r.kt)("img",{src:t(1641).Z})),(0,r.kt)("h2",{id:"project-initialisation"},"Project initialisation"),(0,r.kt)("p",null,"Let's create a React project. To do that, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"npx create-react-app")," command. We will use the ",(0,r.kt)("inlineCode",{parentName:"p"},"typescript")," template:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ npx create-react-app my-Dapp --template typescript # create project\n$ cd my-dapp\n$ yarn start # run project\n")),(0,r.kt)("p",null,"We have a running React application that displays some text. So far, it doesn't do anything else. The first step is to integrate the ",(0,r.kt)("em",{parentName:"p"},"Temple Wallet"),"."),(0,r.kt)("h2",{id:"temple-integration"},"Temple Integration"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@temple-wallet/dapp"},"@temple-wallet/dapp")," module enables a React application to use the ",(0,r.kt)("em",{parentName:"p"},"Temple Wallet")," to interact with a Tezos blockchain. This module uses the ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@taquito/taquito"},"@taquito/taquito")," and ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/constate"},"constate")," modules. Let's install this module:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ yarn add @temple-wallet/dapp\n$ yarn add @taquito/taquito\n$ yarn add constate\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Madfish Solutions")," team provides developers with a ready-to-use script to integrate ",(0,r.kt)("em",{parentName:"p"},"Temple")," into our ",(0,r.kt)("em",{parentName:"p"},"React")," app:\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/madfish-solutions/counter-dapp/blob/master/src/dapp.js"},"https://github.com/madfish-solutions/counter-dapp/blob/master/src/dapp.js")),(0,r.kt)("p",null,"Let's create a ",(0,r.kt)("inlineCode",{parentName:"p"},"dapp")," folder into ",(0,r.kt)("inlineCode",{parentName:"p"},"src/"),", and put the dapp.js file into it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ mkdir src/dapp\n$ cd src/dapp\n$ curl https://raw.githubusercontent.com/madfish-solutions/counter-dapp/master/src/dapp.js -O\n")),(0,r.kt)("p",null,"It exports a ",(0,r.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/context.html"},"React context")," and the necessary functions to interact with a Tezos\nnetwork:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"DAppProvider"),": a react context that will contain all the hooks below."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"useWallet"),": hook returning a Wallet instance that rerenders the views if the wallet changes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"useTezos"),": hook returning a TezosToolkit, using the wallet instance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"useAccountPkh"),": hook returning the current wallet account address (Pkh meaning Public Key Hash)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"useReady"),": hook returning a boolean indicating if the wallet is connected to the tezos network"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"useConnect"),": hook returning a callback to change the user account"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"useOnBlock"),": hook returning a react effect to retrieve the latest baked block. It subscribes to the stream of blocks (watching head) thanks to ",(0,r.kt)("em",{parentName:"li"},"Taquito"),"'s ",(0,r.kt)("inlineCode",{parentName:"li"},"SubscribeProvider")," class.")),(0,r.kt)("p",null,"These hooks will connect our React frontend to the ",(0,r.kt)("em",{parentName:"p"},"Temple Wallet")," extension."),(0,r.kt)("p",null,"Let's modify ",(0,r.kt)("inlineCode",{parentName:"p"},"src/App.tsx"),". We will remove all the HTML elements and add the ",(0,r.kt)("inlineCode",{parentName:"p"},"DAppProvider")," context from the ",(0,r.kt)("inlineCode",{parentName:"p"},"dapp/dapp.js")," file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// dapp/dapp.js\nfunction useDApp({ appName }) {\n  const [{ wallet, tezos, accountPkh }, setState] = React.useState(() => ({\n    wallet: undefined,\n    tezos: undefined,\n    accountPkh: undefined,\n  }))\n\n  const ready = Boolean(tezos)\n\n  React.useEffect(() => {\n    return TempleWallet.onAvailabilityChange((available) => {\n      setState({\n        wallet: available ? new TempleWallet(appName) : undefined,\n        tezos: undefined,\n        accountPkh: undefined,\n      })\n    })\n  }, [setState, appName])\n\n//...\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"useDApp"),' expects one argument, which is the app name. Let\'s call our application "Raffle" and put its name into a constants file in ',(0,r.kt)("inlineCode",{parentName:"p"},"src/dapp/default.ts")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// src/dapp/default.ts\nexport const APP_NAME = 'Raffle';\n")),(0,r.kt)("p",null,"We can add the context into ",(0,r.kt)("inlineCode",{parentName:"p"},"src/App.tsx"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"// src/App.tsx\nimport React from 'react';\nimport { DAppProvider } from \"dapp/dapp\";\nimport { APP_NAME } from './dapp/defaults';\nimport './App.css';\n\nfunction App() {\n    return (\n        <DAppProvider appName={APP_NAME}>\n            <React.Suspense fallback={null}>\n\n            </React.Suspense>\n        < /DAppProvider>\n    );\n}\n\nexport default App;\n\n")),(0,r.kt)("p",null,"Now that we have our context, we can start using the provided hooks."),(0,r.kt)("h3",{id:"wallet-connexion"},"Wallet connexion"),(0,r.kt)("p",null,"The first step is to connect your react app to the ",(0,r.kt)("em",{parentName:"p"},"Temple Wallet"),"."),(0,r.kt)("p",null,"Let's create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Page")," component, that will contain all our components:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"import React from 'react';\nimport { DAppProvider } from './dapp/dapp'\nimport './App.css';\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className=\"App\"> {props.children} </div>\n}\n\nfunction App() {\n  return (\n          <DAppProvider appName={APP_NAME}>\n            <React.Suspense fallback={null}>\n              <Page> </Page>\n            </React.Suspense>\n          </DAppProvider>\n  );\n}\n\nexport default App;\n")),(0,r.kt)("p",null,"Let's add a connexion button. When clicked, the app will connect to the ",(0,r.kt)("em",{parentName:"p"},"Temple Wallet"),".\nWe will use the ",(0,r.kt)("inlineCode",{parentName:"p"},"useConnect")," hook from ",(0,r.kt)("inlineCode",{parentName:"p"},"src/dapp/dapp.js"),". Let's take a look at this callback definition:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// src/dapp/dapp.js\nconst connect = React.useCallback(\n    async (network, opts) => {\n      try {\n        if (!wallet) {\n          throw new Error('Thanos Wallet not available')\n        }\n        await wallet.connect(network, opts) // expects a network and some options\n        const tzs = wallet.toTezos()\n        const pkh = await tzs.wallet.pkh()\n        setState({\n          wallet,\n          tezos: tzs,\n          accountPkh: pkh,\n        })\n      } catch (err) {\n        console.error(`Failed to connect ThanosWallet: ${err.message}`)\n      }\n    },\n    [setState, wallet],\n  )\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"useConnect")," expects two arguments: a Tezos network and some options. Let's define a ",(0,r.kt)("inlineCode",{parentName:"p"},"NETWORK")," global variable into ",(0,r.kt)("inlineCode",{parentName:"p"},"dapp/default.ts")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// src/dapp/default.ts\nexport const APP_NAME = 'Raffle';\nexport const NETWORK = 'edo2net';\n")),(0,r.kt)("p",null,"Our smart contract is deployed on ",(0,r.kt)("em",{parentName:"p"},"Edonet"),": the network is therefore set to ",(0,r.kt)("inlineCode",{parentName:"p"},"edo2net"),"."),(0,r.kt)("p",null,"We can now use the ",(0,r.kt)("inlineCode",{parentName:"p"},"useConnect")," callback. We can define a ",(0,r.kt)("inlineCode",{parentName:"p"},"ConnexionButton")," component that will execute a connexion callback when clicked."),(0,r.kt)("p",null,"We should add the option ",(0,r.kt)("inlineCode",{parentName:"p"},"forcePermission: true")," to force a new connexion if the button is clicked with an already authenticated user:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"function ConnexionButton() {\n  const connect = useConnect()\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n  return <button onClick={handleConnect}>Connect account</button>\n}\n")),(0,r.kt)("p",null,"Our app now looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"import React from 'react';\nimport { DAppProvider, useConnect } from './dapp/dapp'\nimport './App.css';\nimport { APP_NAME, NETWORK } from './dapp/defaults';\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className=\"App\"> {props.children} </div>\n}\n\nfunction ConnexionButton() {\n  const connect = useConnect()\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n  return <button onClick={handleConnect}>Connect account</button>\n}\n\nfunction App() {\n  return (\n          <DAppProvider appName={APP_NAME}>\n            <React.Suspense fallback={null}>\n              <Page>\n                <ConnexionButton></ConnexionButton>\n              </Page>\n            </React.Suspense>\n          </DAppProvider>\n  );\n}\n\nexport default App;\n")),(0,r.kt)("p",null,"Our application contains a single button. If we push it, a pop-up appears and offers the user the ability to connect to its chosen address."),(0,r.kt)("p",null,(0,r.kt)("img",{src:t(4823).Z})),(0,r.kt)("h3",{id:"wallet-information"},"Wallet information"),(0,r.kt)("p",null,"Our application is now connected to the user account on ",(0,r.kt)("em",{parentName:"p"},"Temple"),". However, the application doesn't display some crucial information yet: the used address and its balance."),(0,r.kt)("p",null,"The user needs to know which address is going to interact with the smart contract. This address must therefore hold some funds."),(0,r.kt)("p",null,"Let's add the used address. We will use the ",(0,r.kt)("inlineCode",{parentName:"p"},"useAccountPkh")," callback from ",(0,r.kt)("inlineCode",{parentName:"p"},"dapp/dapp.js"),". The information is therefore set when the connexion is established:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"  const connect = React.useCallback(\n        async (network, opts) => {\n          try {\n            if (!wallet) {\n              throw new Error('Thanos Wallet not available')\n            }\n            await wallet.connect(network, opts)\n            const tzs = wallet.toTezos()\n            const pkh = await tzs.wallet.pkh()\n            setState({\n              wallet,\n              tezos: tzs,\n              accountPkh: pkh, // set here\n            })\n          } catch (err) {\n            console.error(`Failed to connect ThanosWallet: ${err.message}`)\n          }\n        },\n        [setState, wallet],\n)\n")),(0,r.kt)("p",null,"We will call the ",(0,r.kt)("inlineCode",{parentName:"p"},"useAccountPkh")," hook, and reformat the address. The user needs to know which address he's using but we don't have to display all of it (very long) for the user to recognize it, so let's just display the address's beginning and end."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"function ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n\n  const accountPkhPreview = React.useMemo(() => {\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}` // formatting address\n    }\n  }, [accountPkh]) // updates when the connected account changes\n//..\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"accountPkhPreview")," variable must of course be updated when the connected account changes."),(0,r.kt)("p",null,"Next, we will display the balance associated with the connected account. This requires to interact with the Tezos network, so we need the ",(0,r.kt)("inlineCode",{parentName:"p"},"useTezos")," hook."),(0,r.kt)("p",null,"The balance is likely to change when:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the network changes"),(0,r.kt)("li",{parentName:"ul"},"the account changes"),(0,r.kt)("li",{parentName:"ul"},"a new block is baked")),(0,r.kt)("p",null,"We will write our balance update into a react callback, which will be updated if the network, connected account or the page changes."),(0,r.kt)("p",null,"The callback that will be used is in effect if the callback has changed. It will also be used in the ",(0,r.kt)("inlineCode",{parentName:"p"},"useOnBlock")," hook. When a new block is baked, the application will update the balance if it has changed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const loadBalance = React.useCallback(async () => {\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format('mutez', 'tz', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n")),(0,r.kt)("p",null,"Let's change our component into an array of three elements: the balance, the connected user, and the connect button."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"function ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n\n  const accountPkhPreview = React.useMemo(() => {\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}`\n    }\n  }, [accountPkh])\n\n  const loadBalance = React.useCallback(async () => {\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format('mutez', 'tz', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n\n  return <div style={{ display: \"grid\", gridTemplateColumns: '1fr 1fr 1fr', margin: '0 auto', width: \"500px\" }}>\n      <div>{balance}</div>\n      <div>{accountPkhPreview}</div>\n      <button onClick={handleConnect}>Connect account</button>\n    </div>\n}\n")),(0,r.kt)("h2",{id:"displaying-the-storage"},"Displaying the storage"),(0,r.kt)("p",null,"So far, our application uses the ",(0,r.kt)("em",{parentName:"p"},"Temple Wallet")," to connect to a Tezos network using an address. It is now time to connect our React application to our ",(0,r.kt)("em",{parentName:"p"},"Raffle")," smart contract and then to retrieve the contract information (entrypoints and storage)."),(0,r.kt)("p",null,"Let's create a new component that will display the information from the storage. First, we need to retrieve the contract.\nWe need:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the contract address,"),(0,r.kt)("li",{parentName:"ul"},"to connect to a Tezos network using the ",(0,r.kt)("inlineCode",{parentName:"li"},"useTezos")," hook,"),(0,r.kt)("li",{parentName:"ul"},"to save the contract into the component state,"),(0,r.kt)("li",{parentName:"ul"},"to reload the contract whenever the Tezos toolkit changes.")),(0,r.kt)("p",null,"We will put the logic that retrieves the contract into an effect like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"function RaffleInformation() {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  return (\n    <div>\n    </div>\n\n  );\n};\n")),(0,r.kt)("p",null,"The contract object holds several pieces of information:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the address,"),(0,r.kt)("li",{parentName:"ul"},"the entrypoints,"),(0,r.kt)("li",{parentName:"ul"},"the code and storage definition.")),(0,r.kt)("p",null,(0,r.kt)("img",{src:t(295).Z})),(0,r.kt)("p",null,"Let's now take a look at the contract storage. The storage will be kept within the component state. Let's define a ",(0,r.kt)("inlineCode",{parentName:"p"},"RaffleStorage")," type, that will follow the storage definition:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"type RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"BigMapAbstraction")," is an abstraction exported by ",(0,r.kt)("inlineCode",{parentName:"p"},"@taquito/taquito"),". It allows the application to handle ",(0,r.kt)("a",{parentName:"p",href:"https://tezostaquito.io/typedoc/classes/_taquito_taquito.bigmapabstraction.html"},"maps and big maps"),"."),(0,r.kt)("p",null,"Let's fetch the storage from the contract. Let's put the logic of fetching the storage in a react callback: ",(0,r.kt)("inlineCode",{parentName:"p"},"loadStorage"),".\nThe storage is likely to change if the contract's object changes and if a new block is baked. So, this callback will be called from an effect and from the ",(0,r.kt)("inlineCode",{parentName:"p"},"useOnBlock")," hook."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"type RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n\nfunction RaffleInformation() {\n  const tezos = useTezos();\n  const [contract, setContract] = useState();\n  const [tickets, setTickets] = useState<string[]>([]);\n\n  useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n    const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      setStorage(str)\n    }\n  }, [contract]);\n\n    React.useEffect(() => {\n    loadStorage();\n  }, [loadStorage]);\n\n  useOnBlock(tezos, loadStorage)\n\n  return (\n    <div>\n    </div>\n  );\n};\n")),(0,r.kt)("p",null,"One example of a retrieved storage is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'admin: "tz1cGftgD3FuBmBhcwY24RaMm5D2UXLr5LHW"\nclose_date: "2021-07-23T12:59:48.000Z"\ndescription: "Test from dapp"\njackpot: BigNumber {s: 1, e: 1, c: Array(1)}\nplayers: (3) ["tz1beoZXxjqsXGoZnwW4TZD3MWGFpLHRxeFN", "tz1cGftgD3FuBmBhcwY24RaMm5D2UXLr5LHW", "tz1cLMENL1FJYMBJ3WPg5UQAEFobdVPFrdpH"]\nraffle_is_open: true\nsold_tickets: BigMapAbstraction {id: BigNumber, schema: Schema, provider: RpcContractProvider}\nwinning_ticket_number_hash: "74657374"\n')),(0,r.kt)("p",null,"Almost all the values are fetched with ",(0,r.kt)("inlineCode",{parentName:"p"},"contract.storage()"),", except the ",(0,r.kt)("inlineCode",{parentName:"p"},"sold_tickets")," big map."),(0,r.kt)("h3",{id:"handling-big-maps"},"Handling big maps"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Taquito")," does not directly retrieve big maps. This is no surprise as big maps are meant to store a huge amount of data so retrieving the whole big map would take a long time. That is why the wallet returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"BigMapAbstraction"),". This object will be used to retrieve specific values of the big map."),(0,r.kt)("p",null,"In our case, we want to display the tickets and their owner so we need to retrieve all the values. For this, we need to know the keys, which means that we need to get the ids of the sold ticket. ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ecadlabs/taquito/projects/2#card-34204687"},"Big map keys discovery")," is a planned feature for the upcoming versions of ",(0,r.kt)("em",{parentName:"p"},"Taquito"),", but for now we need another solution."),(0,r.kt)("p",null,"There are usually two ways of getting keys of big maps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You can make an API call to an ",(0,r.kt)("a",{parentName:"li",href:"/explorer/tzstats-smart-contract/#api-calls"},"indexer api"),". An indexer monitors a Tezos network and extract and transform data so that it can be easily fetched. Those indexers retrieve the contract big maps, which can be called on from an API endpoint. First, you need to retrieve the big map number. You can find this number in the ",(0,r.kt)("inlineCode",{parentName:"li"},"BigMapAbstraction")," or on an explorer. Once you have this number, you can fetch its keys (and values) with an API key (we use ",(0,r.kt)("a",{parentName:"li",href:"https://tzstats.com/"},"tzstats"),")")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'$ GET https://api.edo.tzstats.com/explorer/bigmap/108024/keys\n[{"key":"0","key_hash":"exprtZBwZUeYYYfUs9B9Rg2ywHezVHnCCnmF9WsDQVrs582dSK63dC","key_binary":"0"},{"key":"1","key_hash":"expru2dKqDfZG8hu4wNGkiyunvq2hdSKuVYtcKta7BWP6Q18oNxKjS","key_binary":"1"},{"key":"2","key_hash":"expruDuAZnFKqmLoisJqUGqrNzXTvw7PJM2rYk97JErM5FHCerQqgn","key_binary":"2"}]\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Alternatively, you could refactor the smart contract to add a ",(0,r.kt)("inlineCode",{parentName:"li"},"set")," in the storage that will hold all the big map keys.")),(0,r.kt)("p",null,"In our ",(0,r.kt)("em",{parentName:"p"},"Raffle")," smart contract, we don't need this as there is a clear one-to-one correspondence between the tickets and the players. If there are five players, it means that exactly five tickets have been sold. Since all tickets are numbered in an ascending order, we can infer that the big map keys range from zero to four."),(0,r.kt)("p",null,"So we create an array of numbers, which ranges from ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"players.length"),". Once we have our keys, we can retrieve the mapped values."),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"BigMapAbstraction")," exposes two asynchronous methods: "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"get"),": takes a big map's key as input and fetches its value."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getMultipleValues"),": takes a list of big map keys as input and fetches several values at the same time.")),(0,r.kt)("p",null,"The correct way to retrieve several values is to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"getMultipleValues")," method. Putting ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," into a ",(0,r.kt)("inlineCode",{parentName:"p"},"for")," loop to retrieve ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," values will make ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," calls: it is not effective when the big map grows."),(0,r.kt)("p",null,"Our ",(0,r.kt)("inlineCode",{parentName:"p"},"loadStorage")," callback now looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"    const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      const ticket_ids = Array.from(Array(str.players.length).keys()) // creating the keys array\n      const tckts = await str.sold_tickets.getMultipleValues(ticket_ids) // fetching the values\n      setStorage(str)\n      setTickets([...tckts.valueMap])\n\n    }\n  }, [contract]);\n")),(0,r.kt)("p",null,"Finally, our storage data will be displayed as plain text. Our ",(0,r.kt)("em",{parentName:"p"},"Raffle")," app now looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'import React, { useState } from \'react\';\nimport { DAppProvider, useAccountPkh, useConnect, useOnBlock, useReady, useTezos, useWallet } from \'./dapp/dapp\'\nimport \'./App.css\';\nimport { APP_NAME, NETWORK, RAFFLE_ADDRESS } from \'./dapp/defaults\';\nimport { BigMapAbstraction } from "@taquito/taquito";\n\ntype RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className="App"> {props.children} </div>\n}\n\nfunction ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n  const accountPkhPreview = React.useMemo(() => {\n    console.log("usememo")\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}`\n    }\n  }, [accountPkh])\n\n  const loadBalance = React.useCallback(async () => {\n    console.log(loadBalance)\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format(\'mutez\', \'tz\', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n\n  return <div>\n    <div style={{ display: "grid", gridTemplateColumns: \'1fr 1fr 1fr\', margin: \'0 auto\', width: "500px" }}>\n      <div>{balance}</div>\n      <div>{accountPkhPreview}</div>\n      <button onClick={handleConnect}>Connect account</button>\n    </div>\n  </div>\n}\n\nfunction RaffleInformation() {\n  const wallet = useWallet();\n  const ready = useReady();\n  const tezos = useTezos();\n\n  const [contract, setContract] = useState();\n  const [storage, setStorage] = useState<RaffleStorage>();\n  const [tickets, setTickets] = useState<string[]>([]);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      const ticket_ids = Array.from(Array(str.players.length).keys())\n      const tckts = await str.sold_tickets.getMultipleValues(ticket_ids)\n      setStorage(str)\n      setTickets([...tckts.valueMap])\n    }\n  }, [contract]);\n\n  React.useEffect(() => {\n    loadStorage();\n  }, [loadStorage]);\n\n  useOnBlock(tezos, loadStorage)\n\n  return (\n    <div>\n      <div>\n        Administrator: {!!storage ? storage.admin.toString() : ""}\n      </div>\n      <div>\n        Reward: {!!storage ? storage.jackpot.toString() : ""}\n      </div>\n      <div>\n        Description: {!!storage ? storage.description.toString() : ""}\n      </div>\n      <div>\n        Players:\n        <div>\n          {!!storage ? storage.players.map((value, index) => {\n            return <li key={index}>{value}</li>\n          }) : ""}\n        </div>\n      </div>\n      <div>\n        Tickets sold:\n        <div>\n          {tickets.map((value, index) => {\n            return <li key={index}>{value[0]} : {value[1]}</li>\n          })}\n        </div>\n      </div>\n\n      <div>\n        Closing date: {!!storage ? storage.close_date.toString() : ""}\n      </div>\n    </div>\n\n  );\n};\n\nfunction App() {\n  return (\n    <DAppProvider appName={APP_NAME}>\n      <React.Suspense fallback={null}>\n        <Page>\n          <ConnectionSection></ConnectionSection>\n          <RaffleInformation></RaffleInformation>\n        </Page>\n      </React.Suspense>\n    </DAppProvider>\n  );\n}\n\nexport default App;\n')),(0,r.kt)("h2",{id:"launching-a-new-raffle"},"Launching a new raffle"),(0,r.kt)("p",null,"It's now time to add interactions with the smart contract. Let's add the possibility to launch a raffle. For this, the user will have to enter the raffle inputs, and then call the ",(0,r.kt)("inlineCode",{parentName:"p"},"openRaffle")," entrypoint."),(0,r.kt)("p",null,"Let's create a ",(0,r.kt)("inlineCode",{parentName:"p"},"LaunchRaffleSection")," component, that will contain a ",(0,r.kt)("inlineCode",{parentName:"p"},"form")," to enter the raffle information, and a button to call the entrypoint."),(0,r.kt)("h3",{id:"new-raffle-information"},"New raffle information"),(0,r.kt)("p",null,"First, we will add a form. Four inputs are needed:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("strong",{parentName:"li"},"reward"),": a ",(0,r.kt)("inlineCode",{parentName:"li"},"string"),","),(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("strong",{parentName:"li"},"description"),": a ",(0,r.kt)("inlineCode",{parentName:"li"},"string"),","),(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("strong",{parentName:"li"},"closing date"),": a ",(0,r.kt)("inlineCode",{parentName:"li"},"Date"),","),(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("strong",{parentName:"li"},"winning ticket hash"),": a ",(0,r.kt)("inlineCode",{parentName:"li"},"string"),".")),(0,r.kt)("p",null,"For the reward, description, and winning ticket hash, a simple ",(0,r.kt)("inlineCode",{parentName:"p"},"<input>")," component will be enough. For the closing date, we can use a ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/react-datepicker"},"DatePicker"),"."),(0,r.kt)("p",null,"These four inputs will be kept in the component state."),(0,r.kt)("h4",{id:"datepicker-installation"},"DatePicker installation"),(0,r.kt)("p",null,"Let's add the ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/react-datepicker"},"react-datepicker")," package:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ yarn add react-datepicker\n")),(0,r.kt)("p",null,"We then need two add two imports into ",(0,r.kt)("em",{parentName:"p"},"App.tsx"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'import DatePicker from "react-datepicker";\nimport "react-datepicker/dist/react-datepicker.css";\n')),(0,r.kt)("h4",{id:"form-creation"},"Form creation"),(0,r.kt)("p",null,"The raffle information will be input in a basic React component like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'\nfunction LaunchRaffleSection() {\n  const [description, setDescription] = useState("");\n  const [reward, setReward] = useState("100");\n  const [closingDate, setClosingDate] = useState(new Date());\n  const [winningTicketHash, setwinningTicketHash] = useState("");\n\n  const setNewDate = (date: any) => {\n    if (!!date) {\n      setClosingDate(date)\n    }\n  }\n\n  return <div style={{ border: "1px solid black" }}>\n    <form>\n      <label>\n        Reward:\n  <input type="text" name="reward" value={reward}\n          onChange={(e) => setReward(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Description:\n  <input type="text" name="description" value={description}\n          onChange={(e) => setDescription(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Closing Date:\n    <DatePicker selected={closingDate} onChange={date => setNewDate(date)}></DatePicker>\n      </label>\n      <br />\n      <label>\n        Winning Hash number:\n    <input type="text" name="winningTicketHash" value={winningTicketHash}\n          onChange={(e) => setwinningTicketHash(e.target.value)} />\n      </label>\n    </form>\n  </div>\n\n}\n')),(0,r.kt)("h3",{id:"new-raffle-button"},"New raffle button"),(0,r.kt)("h4",{id:"web3-installation"},"web3 installation"),(0,r.kt)("p",null,"In this part, we need the standard ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/web3"},"web3 package"),". It is used to interact with ",(0,r.kt)("em",{parentName:"p"},"Ethereum")," networks. In our case, we will be using the ",(0,r.kt)("inlineCode",{parentName:"p"},"utils.asciiToHex")," function to convert ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," into ",(0,r.kt)("inlineCode",{parentName:"p"},"bytes"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ yarn add web3\n")),(0,r.kt)("h4",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"The contract calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"openRaffle")," entrypoint and will use the raffle information entered by the user. First, let's add a button that will trigger this call."),(0,r.kt)("p",null,"Let's create a ",(0,r.kt)("inlineCode",{parentName:"p"},"LaunchRaffleButton")," component. This component will contain the contract call logic."),(0,r.kt)("p",null,"We will call the ",(0,r.kt)("inlineCode",{parentName:"p"},"openRaffle")," entrypoint, it will needs the four inputs from the form. Let's create a props type for this component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"type launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n\n}\n")),(0,r.kt)("p",null,"Before making this contract call, we need to connect to the Tezos network (using the ",(0,r.kt)("inlineCode",{parentName:"p"},"useTezos")," hook) and to get the contract component (the same way we got the ",(0,r.kt)("inlineCode",{parentName:"p"},"RaffleInformation"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"type launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n}\n")),(0,r.kt)("p",null,"The next step is to create the callback that will perform the contract call. This callback will receive the same four arguments as the component. This callback is likely to change if the contract changes."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ContractAbstraction")," now holds the callable entrypoints in ",(0,r.kt)("inlineCode",{parentName:"p"},"methods"),". "),(0,r.kt)("p",null,(0,r.kt)("img",{src:t(4443).Z})),(0,r.kt)("p",null,"It returns three callbacks, matching our three entrypoints. We can now start using the ",(0,r.kt)("inlineCode",{parentName:"p"},"openRaffle")," function. It expects four arguments. The order in which the arguments are expected can be found in ",(0,r.kt)("inlineCode",{parentName:"p"},"entrypoints")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"ContractAbstraction"),"."),(0,r.kt)("p",null,(0,r.kt)("img",{src:t(4398).Z})),(0,r.kt)("p",null,"The order is given by the type:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"reward (",(0,r.kt)("inlineCode",{parentName:"li"},"mutez"),"),"),(0,r.kt)("li",{parentName:"ol"},"closing date (",(0,r.kt)("inlineCode",{parentName:"li"},"timestamps"),"),"),(0,r.kt)("li",{parentName:"ol"},"description (",(0,r.kt)("inlineCode",{parentName:"li"},"option"),"),"),(0,r.kt)("li",{parentName:"ol"},"winning ticket hash (",(0,r.kt)("inlineCode",{parentName:"li"},"bytes"),").")),(0,r.kt)("p",null,"We can now write our callback:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n    },\n    [contract]\n  );\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"web3.utils.asciiToHex(string).slice(2)")," is the way to convert a string into a bytes, using the standard ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/web3"},"web3 package"),"."),(0,r.kt)("p",null,"However, even though the contract arguments are correct, the execution will fail. Indeed, when a raffle is opened, the reward must be sent to the smart contract and an ",(0,r.kt)("inlineCode",{parentName:"p"},"amount")," must be specified. It can be carried out using the ",(0,r.kt)("inlineCode",{parentName:"p"},"send")," method, which specifies some of the parameters of the call:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n        .send({ amount: reward });\n    },\n    [contract]\n  );\n")),(0,r.kt)("p",null,"The last thing we need is to connect this callback to a button. Our final component is therefore:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"type launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n        .send({ amount: reward });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback({\n      reward: raffleReward,\n      description: raffleDescription,\n      closingDate: raffleClosingDate,\n      winningTicketHash: raffleWinningHashNumber\n    })\n  }}>Launch</button>\n}\n")),(0,r.kt)("h3",{id:"end-to-end-testing"},"End-to-end testing"),(0,r.kt)("p",null,"Our app now looks like: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'import React, { useState } from \'react\';\nimport { DAppProvider, useAccountPkh, useConnect, useOnBlock, useReady, useTezos, useWallet } from \'./dapp/dapp\'\nimport \'./App.css\';\nimport { APP_NAME, NETWORK, RAFFLE_ADDRESS } from \'./dapp/defaults\';\nimport { BigMapAbstraction } from "@taquito/taquito";\nimport DatePicker from "react-datepicker";\nimport "react-datepicker/dist/react-datepicker.css";\nimport web3 from "web3";\n\ntype RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className="App"> {props.children} </div>\n}\n\nfunction ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n  const accountPkhPreview = React.useMemo(() => {\n    console.log("usememo")\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}`\n    }\n  }, [accountPkh])\n\n  const loadBalance = React.useCallback(async () => {\n    console.log(loadBalance)\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format(\'mutez\', \'tz\', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n\n  return <div>\n    <div style={{ display: "grid", gridTemplateColumns: \'1fr 1fr 1fr\', margin: \'0 auto\', width: "500px" }}>\n      <div>{balance}</div>\n      <div>{accountPkhPreview}</div>\n      <button onClick={handleConnect}>Connect account</button>\n    </div>\n  </div>\n}\n\nfunction RaffleInformation() {\n  const wallet = useWallet();\n  const ready = useReady();\n  const tezos = useTezos();\n\n  const [contract, setContract] = useState();\n  const [storage, setStorage] = useState<RaffleStorage>();\n  const [tickets, setTickets] = useState<string[]>([]);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      const ticket_ids = Array.from(Array(str.players.length).keys())\n      const tckts = await str.sold_tickets.getMultipleValues(ticket_ids)\n      setStorage(str)\n      setTickets([...tckts.valueMap])\n    }\n  }, [contract]);\n\n  React.useEffect(() => {\n    loadStorage();\n  }, [loadStorage]);\n\n  useOnBlock(tezos, loadStorage)\n\n  return (\n    <div>\n      <div>\n        Administrator: {!!storage ? storage.admin.toString() : ""}\n      </div>\n      <div>\n        Reward: {!!storage ? storage.jackpot.toString() : ""}\n      </div>\n      <div>\n        Description: {!!storage ? storage.description.toString() : ""}\n      </div>\n      <div>\n        Players:\n        <div>\n          {!!storage ? storage.players.map((value, index) => {\n            return <li key={index}>{value}</li>\n          }) : ""}\n        </div>\n      </div>\n      <div>\n        Tickets sold:\n        <div>\n          {tickets.map((value, index) => {\n            return <li key={index}>{value[0]} : {value[1]}</li>\n          })}\n        </div>\n      </div>\n\n      <div>\n        Closing date: {!!storage ? storage.close_date.toString() : ""}\n      </div>\n    </div>\n  );\n};\n\ntype launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n        .send({ amount: reward });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback({\n      reward: raffleReward,\n      description: raffleDescription,\n      closingDate: raffleClosingDate,\n      winningTicketHash: raffleWinningHashNumber\n    })\n  }}>Launch</button>\n}\n\nfunction LaunchRaffleSection() {\n  const [description, setDescription] = useState("");\n  const [reward, setReward] = useState("100");\n  const [closingDate, setClosingDate] = useState(new Date());\n  const [winningTicketHash, setwinningTicketHash] = useState("");\n\n  const setNewDate = (date: any) => {\n    if (!!date) {\n      setClosingDate(date)\n    }\n  }\n\n  return <div style={{ border: "1px solid black" }}>\n    <form>\n      <label>\n        Reward:\n  <input type="text" name="reward" value={reward}\n          onChange={(e) => setReward(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Description:\n  <input type="text" name="description" value={description}\n          onChange={(e) => setDescription(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Closing Date:\n    <DatePicker selected={closingDate} onChange={date => setNewDate(date)}></DatePicker>\n      </label>\n      <br />\n      <label>\n        Winning Hash number:\n    <input type="text" name="winningTicketHash" value={winningTicketHash}\n          onChange={(e) => setwinningTicketHash(e.target.value)} />\n      </label>\n    </form>\n    <LaunchRaffleButton raffleReward={parseInt(reward)} raffleDescription={description} raffleClosingDate={closingDate} raffleWinningHashNumber={winningTicketHash} ></LaunchRaffleButton>\n  </div>\n\n}\n\nfunction App() {\n  return (\n    <DAppProvider appName={APP_NAME}>\n      <React.Suspense fallback={null}>\n        <Page>\n          <ConnectionSection></ConnectionSection>\n          <RaffleInformation></RaffleInformation>\n          <LaunchRaffleSection></LaunchRaffleSection>\n        </Page>\n      </React.Suspense>\n    </DAppProvider>\n  );\n}\n\nexport default App;\n')),(0,r.kt)("p",null,"Let's run it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ yarn start\n")),(0,r.kt)("p",null,"The page should look like this:"),(0,r.kt)("p",null,(0,r.kt)("img",{src:t(5638).Z})),(0,r.kt)("p",null,'Let\'s connect our wallet by clicking on "Connect account". A Temple pop-up should appear and displays the available accounts:\n',(0,r.kt)("img",{src:t(464).Z})),(0,r.kt)("p",null,"The account information are loaded and displayed:\n",(0,r.kt)("img",{src:t(166).Z})),(0,r.kt)("p",null,"Let's create a new raffle: the closing date will be the same day and there will be no winner. Let's click on launch. A pop-up should appear, summing up the contract call:\n",(0,r.kt)("img",{src:t(4113).Z})),(0,r.kt)("p",null,'The detailed transaction information can be found under the "Raw" section:\n',(0,r.kt)("img",{src:t(4256).Z})),(0,r.kt)("p",null,"There is a warning message: ",(0,r.kt)("inlineCode",{parentName:"p"},'"Warning! Transaction is likely to fail"'),". The Temple Wallet is capable, before sending the transaction, to check if the Michelson code will execute successfully. In this case, the closing date is too early. Let's try to send the transaction. If we check in the console, an exception is raised.\n",(0,r.kt)("img",{src:t(2123).Z})),(0,r.kt)("p",null,"The cause of the failure is indeed the closing date. Let's try again: the reward is set at 200 Tez and the end of the raffle is a month later:\n",(0,r.kt)("img",{src:t(7318).Z})),(0,r.kt)("p",null,"The warning is gone. Instead, the fees are displayed. The transaction seems valid: let's send it. After a while, the UI is re-rendered:\n",(0,r.kt)("img",{src:t(277).Z})),(0,r.kt)("p",null,"A raffle just opened. 200 Tez (the reward) has been subtracted from our account balance and the raffle information has been updated."),(0,r.kt)("p",null,"We can try to launch a new raffle, but the transaction will fail since a raffle is already ongoing. This is detected by the Temple Wallet as well."),(0,r.kt)("h2",{id:"buying-tickets"},"Buying tickets"),(0,r.kt)("h3",{id:"implementation-1"},"Implementation"),(0,r.kt)("p",null,"Let's add the feature of buying tickets to our application. There is no information to provide, the only thing required is to call the entrypoint."),(0,r.kt)("p",null,"Just like the opening of a raffle, we need to add a button component that makes that contract call when clicked.\nAs we will need to interact with a contract on a tezos network, we will use the ",(0,r.kt)("inlineCode",{parentName:"p"},"useTezos")," hook and the ",(0,r.kt)("inlineCode",{parentName:"p"},"RAFFLE_ADDRESS")," variable as an effect."),(0,r.kt)("p",null,"The logic of calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"buyTicket")," entrypoint will be written into a React callback. The ticket cost is one Tez."),(0,r.kt)("p",null,"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"buyTicket")," expects a ",(0,r.kt)("inlineCode",{parentName:"p"},"unit"),". It does not mean that no argument should be passed, it expects a ",(0,r.kt)("inlineCode",{parentName:"p"},'"unit"')," string."),(0,r.kt)("p",null,"Finally, this callback will be connected to our button."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'function BuyTicketButton() {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const launchRaffleCallback = React.useCallback(\n    () => {\n      return (contract as any).methods\n        .buyTicket("unit")\n        .send({ amount: 1 });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback()\n  }}>Buy</button>\n}\n')),(0,r.kt)("h3",{id:"end-to-end-testing-1"},"End-to-end testing"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'import React, { useState } from \'react\';\nimport { DAppProvider, useAccountPkh, useConnect, useOnBlock, useReady, useTezos, useWallet } from \'./dapp/dapp\'\nimport \'./App.css\';\nimport { APP_NAME, NETWORK, RAFFLE_ADDRESS } from \'./dapp/defaults\';\nimport { BigMapAbstraction } from "@taquito/taquito";\nimport DatePicker from "react-datepicker";\nimport "react-datepicker/dist/react-datepicker.css";\nimport web3 from "web3";\n\ntype RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className="App"> {props.children} </div>\n}\n\nfunction ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n\n  const accountPkhPreview = React.useMemo(() => {\n    console.log("usememo")\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}`\n    }\n  }, [accountPkh])\n\n  const loadBalance = React.useCallback(async () => {\n    console.log(loadBalance)\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format(\'mutez\', \'tz\', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n\n  return <div>\n    <div style={{ display: "grid", gridTemplateColumns: \'1fr 1fr 1fr\', margin: \'0 auto\', width: "500px" }}>\n      <div>{balance}</div>\n      <div>{accountPkhPreview}</div>\n      <button onClick={handleConnect}>Connect account</button>\n    </div>\n  </div>\n\n}\n\nfunction RaffleInformation() {\n  const wallet = useWallet();\n  const ready = useReady();\n  const tezos = useTezos();\n\n  const [contract, setContract] = useState();\n  const [storage, setStorage] = useState<RaffleStorage>();\n  const [tickets, setTickets] = useState<string[]>([]);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        debugger\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      const ticket_ids = Array.from(Array(str.players.length).keys())\n      const tckts = await str.sold_tickets.getMultipleValues(ticket_ids)\n      setStorage(str)\n      setTickets([...tckts.valueMap])\n    }\n  }, [contract]);\n\n  React.useEffect(() => {\n    loadStorage();\n  }, [loadStorage]);\n\n  useOnBlock(tezos, loadStorage)\n\n  return (\n    <div>\n      <div>\n        Administrator: {!!storage ? storage.admin.toString() : ""}\n      </div>\n      <div>\n        Reward: {!!storage ? storage.jackpot.toString() : ""}\n      </div>\n      <div>\n        Description: {!!storage ? storage.description.toString() : ""}\n      </div>\n      <div>\n        Players:\n        <div>\n          {!!storage ? storage.players.map((value, index) => {\n            return <li key={index}>{value}</li>\n          }) : ""}\n        </div>\n      </div>\n      <div>\n        Tickets sold:\n        <div>\n          {tickets.map((value, index) => {\n            return <li key={index}>{value[0]} : {value[1]}</li>\n          })}\n        </div>\n      </div>\n\n      <div>\n        Closing date: {!!storage ? storage.close_date.toString() : ""}\n      </div>\n    </div>\n\n  );\n};\n\ntype launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n        .send({ amount: reward });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback({\n      reward: raffleReward,\n      description: raffleDescription,\n      closingDate: raffleClosingDate,\n      winningTicketHash: raffleWinningHashNumber\n    })\n  }}>Launch</button>\n}\n\nfunction LaunchRaffleSection() {\n  const [description, setDescription] = useState("");\n  const [reward, setReward] = useState("100");\n  const [closingDate, setClosingDate] = useState(new Date());\n  const [winningTicketHash, setwinningTicketHash] = useState("");\n\n  const setNewDate = (date: any) => {\n    if (!!date) {\n      setClosingDate(date)\n    }\n  }\n\n  return <div style={{ border: "1px solid black" }}>\n    <form>\n      <label>\n        Reward:\n  <input type="text" name="reward" value={reward}\n          onChange={(e) => setReward(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Description:\n  <input type="text" name="description" value={description}\n          onChange={(e) => setDescription(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Closing Date:\n    <DatePicker selected={closingDate} onChange={date => setNewDate(date)}></DatePicker>\n      </label>\n      <br />\n      <label>\n        Winning Hash number:\n    <input type="text" name="winningTicketHash" value={winningTicketHash}\n          onChange={(e) => setwinningTicketHash(e.target.value)} />\n      </label>\n    </form>\n    <LaunchRaffleButton raffleReward={parseInt(reward)} raffleDescription={description} raffleClosingDate={closingDate} raffleWinningHashNumber={winningTicketHash} ></LaunchRaffleButton>\n  </div>\n\n}\n\nfunction BuyTicketButton() {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const launchRaffleCallback = React.useCallback(\n    () => {\n      return (contract as any).methods\n        .buyTicket("unit")\n        .send({ amount: 1 });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback()\n  }}>Buy</button>\n}\n\nfunction App() {\n  return (\n    <DAppProvider appName={APP_NAME}>\n      <React.Suspense fallback={null}>\n        <Page>\n          <ConnectionSection></ConnectionSection>\n          <RaffleInformation></RaffleInformation>\n          <LaunchRaffleSection></LaunchRaffleSection>\n          <BuyTicketButton></BuyTicketButton>\n        </Page>\n      </React.Suspense>\n    </DAppProvider>\n  );\n}\n\nexport default App;\n')),(0,r.kt)("p",null,"Let's test it. The button to buy a ticket has been added and can be clicked. A Temple wallet pop-up appears, summing up the contract call:\n",(0,r.kt)("img",{src:t(2230).Z})),(0,r.kt)("p",null,"After a while, the UI is re-rendered. The bought ticket is displayed.\n",(0,r.kt)("img",{src:t(4127).Z})),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"Integrating the Temple wallet into a React app can be broken down into three steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"using the context provider,"),(0,r.kt)("li",{parentName:"ol"},"connecting the React app to the Wallet (with ",(0,r.kt)("inlineCode",{parentName:"li"},"useConnect"),"),"),(0,r.kt)("li",{parentName:"ol"},"interacting with the contract (storage or contract calls).")),(0,r.kt)("p",null,"We have covered the basic functionalities of the ",(0,r.kt)("em",{parentName:"p"},"Temple dapp")," module. In the next chapter, we will improve the user experience for all the blockchain interactions."))}d.isMDXComponent=!0},4823:function(e,n,t){n.Z=t.p+"assets/images/front1-013427e8f1e012269215902cf92b5d08.png"},2123:function(e,n,t){n.Z=t.p+"assets/images/front10-48342678a3f6c70948f215e46383e638.png"},7318:function(e,n,t){n.Z=t.p+"assets/images/front11-e5be76b5f13c495363ace98bffab1e62.png"},277:function(e,n,t){n.Z=t.p+"assets/images/front12-dc2fbda8b0dd7672447e7713d174fb6f.png"},2230:function(e,n,t){n.Z=t.p+"assets/images/front13-561b037cebca6e0111c45471cf4fb124.png"},4127:function(e,n,t){n.Z=t.p+"assets/images/front14-7a6342dd5f158456e9ac359b800599c8.png"},295:function(e,n,t){n.Z=t.p+"assets/images/front2-ced586f3745bd9b4c03c1ffc4a0f7390.png"},1641:function(e,n,t){n.Z=t.p+"assets/images/front21-dec364ff8062203b20bb9227d5e82dd5.png"},4443:function(e,n,t){n.Z=t.p+"assets/images/front3-309923828c096cec2d28f0f2f71cf06e.png"},4398:function(e,n,t){n.Z=t.p+"assets/images/front4-42e98e5aa5a380f4dbbd52940524ad00.png"},5638:function(e,n,t){n.Z=t.p+"assets/images/front5-538d8a71a4b3124a8dc1e4e00e235150.png"},464:function(e,n,t){n.Z=t.p+"assets/images/front6-521a214a72acb6954f3b0cbdc3c408cc.png"},166:function(e,n,t){n.Z=t.p+"assets/images/front7-84a3ea0ef9a9de19c28488a4ae242b95.png"},4113:function(e,n,t){n.Z=t.p+"assets/images/front8-95b4f7d63da79d3bea7f688879447baf.png"},4256:function(e,n,t){n.Z=t.p+"assets/images/front9-d0a193dac6c95ec773cd3265088ac254.png"}}]);